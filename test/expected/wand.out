-- BMW Multi-term WAND Traversal Test
--
-- Regression test for doc-ID ordered traversal in multi-term queries.
-- Ensures documents at different block positions across posting lists
-- are correctly scored.
CREATE EXTENSION pg_textsearch;
INFO:  pg_textsearch v0.3.0-dev: This is prerelease software and should not be used in production.
INFO:  This release contains breaking changes in the bm25 index structure and will require existing indexes to be rebuilt.
-- ============================================================
-- TEST: Multi-term documents score correctly across block boundaries
-- ============================================================
CREATE TABLE bmw_bug (id SERIAL PRIMARY KEY, content TEXT);
CREATE INDEX bmw_bug_idx ON bmw_bug USING bm25(content) WITH (text_config='english');
NOTICE:  BM25 index build started for relation bmw_bug_idx
NOTICE:  Using text search configuration: english
NOTICE:  Using index options: k1=1.20, b=0.75
NOTICE:  BM25 index build completed: 0 documents, avg_length=0.00, text_config='english' (k1=1.20, b=0.75)
-- Insert in order that puts multi-term doc at different block positions:
-- 200 alpha-only docs, then 1 multi-term, then 500 beta-only docs
INSERT INTO bmw_bug (content) SELECT 'alpha only ' || i FROM generate_series(1, 200) i;
INSERT INTO bmw_bug (content) VALUES ('alpha beta both terms here');  -- id=201
INSERT INTO bmw_bug (content) SELECT 'beta only ' || i FROM generate_series(202, 700) i;
-- Spill to segment (creates single segment with all 700 docs)
SELECT bm25_spill_index('bmw_bug_idx');
 bm25_spill_index 
------------------
                2
(1 row)

-- Posting list layout in segment:
-- "alpha": 201 postings (docs 1-200, 201)
--   - Block 0: docs 1-128
--   - Block 1: docs 129-200, 201 (doc 201 at position 200)
-- "beta": 500 postings (doc 201, docs 202-700)
--   - Block 0: docs 201, 202-329 (doc 201 at position 0)
--   - Block 1: docs 330-457
--   - Block 2: docs 458-585
--   - Block 3: docs 586-700
--
-- Doc 201 is at:
--   - "alpha" block 1 (near end of short list)
--   - "beta" block 0 (at start of long list)
--
-- When BMW processes by block_idx:
--   block 0: finds doc 201 in beta only -> partial score
--   block 1: finds doc 201 in alpha only -> partial score
-- Neither score is the correct combined score!
-- Get ground truth with exhaustive scoring
SET pg_textsearch.enable_bmw = off;
CREATE TEMP TABLE exhaustive_results AS
SELECT id, content <@> to_bm25query('alpha beta', 'bmw_bug_idx') as score
FROM bmw_bug
WHERE content <@> to_bm25query('alpha beta', 'bmw_bug_idx') < 0
ORDER BY score LIMIT 10;
-- Get BMW results
SET pg_textsearch.enable_bmw = on;
CREATE TEMP TABLE bmw_results AS
SELECT id, content <@> to_bm25query('alpha beta', 'bmw_bug_idx') as score
FROM bmw_bug
WHERE content <@> to_bm25query('alpha beta', 'bmw_bug_idx') < 0
ORDER BY score LIMIT 10;
-- Show both result sets
SELECT 'exhaustive' as path, * FROM exhaustive_results ORDER BY score;
    path    | id  |        score        
------------+-----+---------------------
 exhaustive | 201 | -1.3151806592941284
 exhaustive |   1 | -1.2470827102661133
 exhaustive |   2 | -1.2470827102661133
 exhaustive |   3 | -1.2470827102661133
 exhaustive |   4 | -1.2470827102661133
 exhaustive |   5 | -1.2470827102661133
 exhaustive |   6 | -1.2470827102661133
 exhaustive |   7 | -1.2470827102661133
 exhaustive |   8 | -1.2470827102661133
 exhaustive |   9 | -1.2470827102661133
(10 rows)

SELECT 'bmw' as path, * FROM bmw_results ORDER BY score;
 path | id  |        score        
------+-----+---------------------
 bmw  | 201 | -1.3151806592941284
 bmw  |   1 | -1.2470827102661133
 bmw  |   2 | -1.2470827102661133
 bmw  |   3 | -1.2470827102661133
 bmw  |   4 | -1.2470827102661133
 bmw  |   5 | -1.2470827102661133
 bmw  |   6 | -1.2470827102661133
 bmw  |   7 | -1.2470827102661133
 bmw  |   8 | -1.2470827102661133
 bmw  |   9 | -1.2470827102661133
(10 rows)

-- TEST 1: Doc 201 should be in top 10 of exhaustive (it's the ONLY multi-term doc!)
SELECT 'exhaustive-has-201' as test,
    CASE WHEN 201 IN (SELECT id FROM exhaustive_results)
    THEN 'PASS' ELSE 'FAIL' END as result;
        test        | result 
--------------------+--------
 exhaustive-has-201 | PASS
(1 row)

-- TEST 2: Doc 201 should be in top 10 of BMW (THIS FAILS - THE BUG!)
SELECT 'bmw-has-201' as test,
    CASE WHEN 201 IN (SELECT id FROM bmw_results)
    THEN 'PASS' ELSE 'FAIL - DOC 201 MISSING DUE TO PARTIAL SCORING BUG' END as result;
    test     | result 
-------------+--------
 bmw-has-201 | PASS
(1 row)

-- TEST 3: Doc 201 should be #1 in exhaustive (best score)
SELECT 'exhaustive-201-is-top' as test,
    CASE WHEN (SELECT id FROM exhaustive_results ORDER BY score LIMIT 1) = 201
    THEN 'PASS' ELSE 'FAIL' END as result;
         test          | result 
-----------------------+--------
 exhaustive-201-is-top | PASS
(1 row)

-- TEST 4: Results should match between BMW and exhaustive
SELECT 'results-match' as test,
    CASE WHEN (SELECT COUNT(*) FROM
        (SELECT id FROM exhaustive_results EXCEPT SELECT id FROM bmw_results) x) = 0
    THEN 'PASS' ELSE 'FAIL - RESULTS DIFFER' END as result;
     test      | result 
---------------+--------
 results-match | PASS
(1 row)

-- Show what score doc 201 SHOULD have
SET pg_textsearch.enable_bmw = off;
SELECT 'correct-score-for-201' as info,
    content <@> to_bm25query('alpha beta', 'bmw_bug_idx') as expected_score
FROM bmw_bug WHERE id = 201;
         info          |   expected_score    
-----------------------+---------------------
 correct-score-for-201 | -1.3151806592941284
(1 row)

DROP TABLE exhaustive_results, bmw_results;
DROP TABLE bmw_bug;
-- ============================================================
-- TEST: 3-term query with multiple blocks (buffer management)
-- ============================================================
-- This tests a bug where zero-copy buffer pins were shared with the
-- reader's cached buffer. When initializing multiple term iterators,
-- reading the dictionary for term N could release the buffer that
-- term N-1's iterator was still using.
CREATE TABLE three_term (id SERIAL PRIMARY KEY, content TEXT);
CREATE INDEX three_term_idx ON three_term USING bm25(content)
    WITH (text_config='english');
NOTICE:  BM25 index build started for relation three_term_idx
NOTICE:  Using text search configuration: english
NOTICE:  Using index options: k1=1.20, b=0.75
NOTICE:  BM25 index build completed: 0 documents, avg_length=0.00, text_config='english' (k1=1.20, b=0.75)
-- Create layout with multiple blocks per term
INSERT INTO three_term (content)
    SELECT 'alpha only ' || i FROM generate_series(1, 150) i;
INSERT INTO three_term (content)
    VALUES ('alpha beta two terms');  -- id=151
INSERT INTO three_term (content)
    SELECT 'beta only ' || i FROM generate_series(152, 351) i;
INSERT INTO three_term (content)
    VALUES ('alpha beta gamma three terms here');  -- id=352
INSERT INTO three_term (content)
    SELECT 'gamma only ' || i FROM generate_series(353, 652) i;
SELECT bm25_spill_index('three_term_idx');
 bm25_spill_index 
------------------
                2
(1 row)

-- Get ground truth with exhaustive scoring
SET pg_textsearch.enable_bmw = off;
CREATE TEMP TABLE ex_3term AS
SELECT id, content <@> to_bm25query('alpha beta gamma', 'three_term_idx') as score
FROM three_term
WHERE content <@> to_bm25query('alpha beta gamma', 'three_term_idx') < 0
ORDER BY score LIMIT 10;
-- Get BMW results
SET pg_textsearch.enable_bmw = on;
CREATE TEMP TABLE bmw_3term AS
SELECT id, content <@> to_bm25query('alpha beta gamma', 'three_term_idx') as score
FROM three_term
WHERE content <@> to_bm25query('alpha beta gamma', 'three_term_idx') < 0
ORDER BY score LIMIT 10;
-- Show both result sets
SELECT 'exhaustive-3term' as mode, * FROM ex_3term ORDER BY score LIMIT 5;
       mode       | id  |        score        
------------------+-----+---------------------
 exhaustive-3term | 352 | -2.1109485924243927
 exhaustive-3term | 151 | -1.8672218322753906
 exhaustive-3term |   1 | -1.4566887617111206
 exhaustive-3term |   2 | -1.4566887617111206
 exhaustive-3term |   3 | -1.4566887617111206
(5 rows)

SELECT 'bmw-3term' as mode, * FROM bmw_3term ORDER BY score LIMIT 5;
   mode    | id  |        score        
-----------+-----+---------------------
 bmw-3term | 352 | -2.1109485924243927
 bmw-3term | 151 | -1.8672218322753906
 bmw-3term |   1 | -1.4566887617111206
 bmw-3term |   2 | -1.4566887617111206
 bmw-3term |   3 | -1.4566887617111206
(5 rows)

-- TEST 5: Doc 352 (3-term doc) should be #1 in both
SELECT '3-term-352-is-top' as test,
    CASE WHEN (SELECT id FROM ex_3term ORDER BY score LIMIT 1) = 352
         AND (SELECT id FROM bmw_3term ORDER BY score LIMIT 1) = 352
    THEN 'PASS' ELSE 'FAIL' END as result;
       test        | result 
-------------------+--------
 3-term-352-is-top | PASS
(1 row)

-- TEST 6: 3-term results should match
SELECT '3-term-results-match' as test,
    CASE WHEN (SELECT COUNT(*) FROM
        (SELECT id FROM ex_3term EXCEPT SELECT id FROM bmw_3term) x) = 0
    THEN 'PASS' ELSE 'FAIL - 3-TERM RESULTS DIFFER' END as result;
         test         | result 
----------------------+--------
 3-term-results-match | PASS
(1 row)

DROP TABLE ex_3term, bmw_3term;
DROP TABLE three_term;
DROP EXTENSION pg_textsearch CASCADE;
