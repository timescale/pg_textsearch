-- Test concurrent operations on pg_textsearch indexes
-- This test verifies that concurrent access to shared memory structures is safe
-- and that operations like inserts, searches, and index building work correctly
CREATE EXTENSION IF NOT EXISTS pg_textsearch;
INFO:  pg_textsearch v0.3.0-dev: This is prerelease software and should not be used in production.
INFO:  This release contains breaking changes in the bm25 index structure and will require existing indexes to be rebuilt.
-- Enable score logging for testing
SET pg_textsearch.log_scores = true;
-- Clean up from any previous tests
DROP TABLE IF EXISTS concurrent_test_docs CASCADE;
NOTICE:  table "concurrent_test_docs" does not exist, skipping
DROP TABLE IF EXISTS concurrent_test_docs2 CASCADE;
NOTICE:  table "concurrent_test_docs2" does not exist, skipping
-- Create test tables for concurrent operations
CREATE TABLE concurrent_test_docs (
    id SERIAL PRIMARY KEY,
    content TEXT NOT NULL,
    category VARCHAR(50),
    created_at TIMESTAMP DEFAULT NOW()
);
CREATE TABLE concurrent_test_docs2 (
    id SERIAL PRIMARY KEY,
    content TEXT NOT NULL,
    priority INTEGER DEFAULT 1
);
-- Test 1: Sequential inserts to verify basic functionality
\echo 'Test 1: Sequential baseline test'
Test 1: Sequential baseline test
INSERT INTO concurrent_test_docs (content, category) VALUES
('database query optimization techniques', 'tech'),
('concurrent programming patterns', 'tech'),
('shared memory management systems', 'tech'),
('lock-free data structures', 'tech'),
('database indexing strategies', 'tech');
-- Create index after initial data
CREATE INDEX concurrent_idx1 ON concurrent_test_docs USING bm25(content)
  WITH (text_config='english', k1=1.2, b=0.75);
NOTICE:  BM25 index build started for relation concurrent_idx1
NOTICE:  Using text search configuration: english
NOTICE:  Using index options: k1=1.20, b=0.75
NOTICE:  BM25 index build completed: 5 documents, avg_length=3.80, text_config='english' (k1=1.20, b=0.75)
-- Verify basic search works (only matching documents via index)
SELECT id, content, ROUND((content <@> to_bm25query('database concurrent', 'concurrent_idx1'))::numeric, 4) as score
FROM concurrent_test_docs
ORDER BY content <@> to_bm25query('database concurrent', 'concurrent_idx1')
LIMIT 10;
NOTICE:  BM25 index scan: tid=(0,2), BM25_score=-1.5169
NOTICE:  BM25 index scan: tid=(0,5), BM25_score=-0.9580
NOTICE:  BM25 index scan: tid=(0,1), BM25_score=-0.8570
 id |                content                 |  score  
----+----------------------------------------+---------
  2 | concurrent programming patterns        | -1.5169
  5 | database indexing strategies           | -0.9580
  1 | database query optimization techniques | -0.8570
(3 rows)

-- Test 2: Simulate concurrent inserts with same terms
\echo 'Test 2: Concurrent inserts with overlapping terms'
Test 2: Concurrent inserts with overlapping terms
-- Insert documents that will compete for same posting lists
INSERT INTO concurrent_test_docs (content, category) VALUES
('database systems require concurrent access control', 'tech'),
('concurrent database operations need careful synchronization', 'tech'),
('database concurrent processing improves performance', 'tech');
-- Search to verify posting lists updated correctly
SELECT id, content, ROUND((content <@> to_bm25query('database concurrent', 'concurrent_idx1'))::numeric, 4) as score
FROM concurrent_test_docs
ORDER BY score
LIMIT 5;
 id |                           content                           |  score  
----+-------------------------------------------------------------+---------
  8 | database concurrent processing improves performance         | -1.1341
  6 | database systems require concurrent access control          | -1.0433
  7 | concurrent database operations need careful synchronization | -1.0433
  2 | concurrent programming patterns                             | -0.8026
  5 | database indexing strategies                                | -0.5702
(5 rows)

-- Test 3: Multiple index creation (simulates concurrent index builds)
\echo 'Test 3: Multiple index creation'
Test 3: Multiple index creation
-- Create second table and index to test multiple indexes
INSERT INTO concurrent_test_docs2 (content, priority) VALUES
('high priority database tasks', 3),
('concurrent processing systems', 2),
('shared memory data structures', 1),
('database performance optimization', 3),
('concurrent system design patterns', 2);
CREATE INDEX concurrent_idx2 ON concurrent_test_docs2 USING bm25(content)
  WITH (text_config='english', k1=1.5, b=0.8);
NOTICE:  BM25 index build started for relation concurrent_idx2
NOTICE:  Using text search configuration: english
NOTICE:  Using index options: k1=1.50, b=0.80
NOTICE:  BM25 index build completed: 5 documents, avg_length=3.60, text_config='english' (k1=1.50, b=0.80)
-- Verify both indexes work independently
SELECT 'Table 1' as source, id, content
FROM concurrent_test_docs
UNION ALL
SELECT 'Table 2' as source, id, content
FROM concurrent_test_docs2
ORDER BY source, id;
 source  | id |                           content                           
---------+----+-------------------------------------------------------------
 Table 1 |  1 | database query optimization techniques
 Table 1 |  2 | concurrent programming patterns
 Table 1 |  3 | shared memory management systems
 Table 1 |  4 | lock-free data structures
 Table 1 |  5 | database indexing strategies
 Table 1 |  6 | database systems require concurrent access control
 Table 1 |  7 | concurrent database operations need careful synchronization
 Table 1 |  8 | database concurrent processing improves performance
 Table 2 |  1 | high priority database tasks
 Table 2 |  2 | concurrent processing systems
 Table 2 |  3 | shared memory data structures
 Table 2 |  4 | database performance optimization
 Table 2 |  5 | concurrent system design patterns
(13 rows)

-- Test 4: Stress test with many inserts
\echo 'Test 4: Bulk insert stress test'
Test 4: Bulk insert stress test
-- Generate series of documents with overlapping terms
INSERT INTO concurrent_test_docs (content, category)
SELECT
    'test document number ' || i || ' contains database and concurrent terms',
    'stress'
FROM generate_series(1, 50) i;
-- Verify search still works with larger dataset
SELECT COUNT(*) as total_matches
FROM concurrent_test_docs;
 total_matches 
---------------
            58
(1 row)

-- Test top results still make sense
SELECT id, substring(content, 1, 50) || '...' as content_preview,
       ROUND((content <@> to_bm25query('database concurrent', 'concurrent_idx1'))::numeric, 4) as score
FROM concurrent_test_docs
ORDER BY score
LIMIT 8;
 id |                    content_preview                    |  score  
----+-------------------------------------------------------+---------
  8 | database concurrent processing improves performanc... | -0.1628
  7 | concurrent database operations need careful synchr... | -0.1531
  6 | database systems require concurrent access control... | -0.1531
 10 | test document number 2 contains database and concu... | -0.1369
  9 | test document number 1 contains database and concu... | -0.1369
 11 | test document number 3 contains database and concu... | -0.1369
 12 | test document number 4 contains database and concu... | -0.1369
 13 | test document number 5 contains database and concu... | -0.1369
(8 rows)

-- Test 5: Mixed operations (insert while searching)
\echo 'Test 5: Mixed insert and search operations'
Test 5: Mixed insert and search operations
-- This simulates a session inserting while another searches
BEGIN;
    INSERT INTO concurrent_test_docs (content, category) VALUES
    ('new concurrent database research paper', 'research');
    -- Search within same transaction
    SELECT id, content, ROUND((content <@> to_bm25query('research database', 'concurrent_idx1'))::numeric, 4) as score
    FROM concurrent_test_docs
    ORDER BY score
    LIMIT 3;
 id |                content                 |  score  
----+----------------------------------------+---------
 59 | new concurrent database research paper | -4.3363
  5 | database indexing strategies           | -0.0796
  1 | database query optimization techniques | -0.0742
(3 rows)

COMMIT;
-- Verify the insert is visible after commit
SELECT id, content, ROUND((content <@> to_bm25query('research database', 'concurrent_idx1'))::numeric, 4) as score
FROM concurrent_test_docs
ORDER BY score
LIMIT 3;
 id |                content                 |  score  
----+----------------------------------------+---------
 59 | new concurrent database research paper | -4.3363
  5 | database indexing strategies           | -0.0796
  1 | database query optimization techniques | -0.0742
(3 rows)

-- Test 6: Index integrity under updates
\echo 'Test 6: Update operations'
Test 6: Update operations
-- Update some documents to test posting list maintenance
UPDATE concurrent_test_docs
SET content = 'updated database system with enhanced concurrent features'
WHERE id IN (1, 2);
-- Verify search finds updated documents
SELECT id, content, ROUND((content <@> to_bm25query('enhanced database', 'concurrent_idx1'))::numeric, 4) as score
FROM concurrent_test_docs
ORDER BY content <@> to_bm25query('enhanced database', 'concurrent_idx1')
LIMIT 10;
NOTICE:  BM25 index scan: tid=(0,60), BM25_score=-3.5477
NOTICE:  BM25 index scan: tid=(0,61), BM25_score=-3.5477
NOTICE:  BM25 index scan: tid=(0,5), BM25_score=-0.0768
NOTICE:  BM25 index scan: tid=(0,1), BM25_score=-0.0716
NOTICE:  BM25 index scan: tid=(0,8), BM25_score=-0.0671
NOTICE:  BM25 index scan: tid=(0,59), BM25_score=-0.0671
NOTICE:  BM25 index scan: tid=(0,6), BM25_score=-0.0631
NOTICE:  BM25 index scan: tid=(0,7), BM25_score=-0.0631
NOTICE:  BM25 index scan: tid=(0,9), BM25_score=-0.0563
NOTICE:  BM25 index scan: tid=(0,10), BM25_score=-0.0563
 id |                            content                            |  score  
----+---------------------------------------------------------------+---------
  1 | updated database system with enhanced concurrent features     | -3.5477
  2 | updated database system with enhanced concurrent features     | -3.5477
  5 | database indexing strategies                                  | -0.0768
  8 | database concurrent processing improves performance           | -0.0671
 59 | new concurrent database research paper                        | -0.0671
  6 | database systems require concurrent access control            | -0.0631
  7 | concurrent database operations need careful synchronization   | -0.0631
  9 | test document number 1 contains database and concurrent terms | -0.0563
 10 | test document number 2 contains database and concurrent terms | -0.0563
(9 rows)

-- Test 7: Delete operations
\echo 'Test 7: Delete operations'
Test 7: Delete operations
-- Count before delete
SELECT COUNT(*) as count_before_delete
FROM concurrent_test_docs;
 count_before_delete 
---------------------
                  59
(1 row)

-- Delete some stress test documents
DELETE FROM concurrent_test_docs
WHERE content LIKE 'test document number%' AND id % 5 = 0;
-- Count after delete to verify cleanup
SELECT COUNT(*) as count_after_delete
FROM concurrent_test_docs;
 count_after_delete 
--------------------
                 49
(1 row)

-- Test 8: Verify string interning consistency
\echo 'Test 8: String interning consistency'
Test 8: String interning consistency
-- Insert documents with exact same terms to test string interning
INSERT INTO concurrent_test_docs (content, category) VALUES
('exact same terms for testing consistency', 'test'),
('exact same terms for testing consistency', 'test'),
('testing consistency with exact same terms', 'test');
-- Search should find all variants
SELECT id, content, ROUND((content <@> to_bm25query('exact same terms', 'concurrent_idx1'))::numeric, 4) as score
FROM concurrent_test_docs
ORDER BY content <@> to_bm25query('exact same terms', 'concurrent_idx1'), id
LIMIT 10;
 id |                            content                            |  score  
----+---------------------------------------------------------------+---------
 60 | exact same terms for testing consistency                      | -3.8184
 61 | exact same terms for testing consistency                      | -3.8184
 62 | testing consistency with exact same terms                     | -3.8184
  9 | test document number 1 contains database and concurrent terms | -0.1870
 11 | test document number 3 contains database and concurrent terms | -0.1870
 12 | test document number 4 contains database and concurrent terms | -0.1870
 13 | test document number 5 contains database and concurrent terms | -0.1870
 14 | test document number 6 contains database and concurrent terms | -0.1870
 16 | test document number 8 contains database and concurrent terms | -0.1870
 17 | test document number 9 contains database and concurrent terms | -0.1870
(10 rows)

-- Test 9: Multiple indexes on same table
\echo 'Test 9: Multiple indexes on same table'
Test 9: Multiple indexes on same table
-- Create a test table for multiple indexes
CREATE TABLE multi_idx_test (
    id SERIAL PRIMARY KEY,
    content TEXT NOT NULL
);
-- Insert initial data
INSERT INTO multi_idx_test (content) VALUES
('hello world from the test'),
('the quick brown fox jumps'),
('hello from another document');
-- Create two indexes with different text configurations
CREATE INDEX multi_idx_english ON multi_idx_test USING bm25(content)
  WITH (text_config='english', k1=1.2, b=0.75);
NOTICE:  BM25 index build started for relation multi_idx_english
NOTICE:  Using text search configuration: english
NOTICE:  Using index options: k1=1.20, b=0.75
NOTICE:  BM25 index build completed: 3 documents, avg_length=3.33, text_config='english' (k1=1.20, b=0.75)
CREATE INDEX multi_idx_simple ON multi_idx_test USING bm25(content)
  WITH (text_config='simple', k1=1.5, b=0.8);
NOTICE:  BM25 index build started for relation multi_idx_simple
NOTICE:  Using text search configuration: simple
NOTICE:  Using index options: k1=1.50, b=0.80
NOTICE:  BM25 index build completed: 3 documents, avg_length=4.67, text_config='simple' (k1=1.50, b=0.80)
-- Insert more data after index creation
INSERT INTO multi_idx_test (content) VALUES
('world of databases and indexes'),
('hello database world');
-- Query using the English index
SELECT id, content, ROUND((content <@> to_bm25query('hello world', 'multi_idx_english'))::numeric, 4) as english_score
FROM multi_idx_test
ORDER BY content <@> to_bm25query('hello world', 'multi_idx_english')
LIMIT 10;
NOTICE:  BM25 index scan: tid=(0,5), BM25_score=-1.2723
NOTICE:  BM25 index scan: tid=(0,1), BM25_score=-1.0118
NOTICE:  BM25 index scan: tid=(0,3), BM25_score=-0.5636
NOTICE:  BM25 index scan: tid=(0,4), BM25_score=-0.5059
 id |            content             | english_score 
----+--------------------------------+---------------
  5 | hello database world           |       -1.1063
  1 | hello world from the test      |       -1.1063
  3 | hello from another document    |       -0.5531
  4 | world of databases and indexes |       -0.5531
(4 rows)

-- Query using the Simple index
SELECT id, content, ROUND((content <@> to_bm25query('hello world', 'multi_idx_simple'))::numeric, 4) as simple_score
FROM multi_idx_test
ORDER BY content <@> to_bm25query('hello world', 'multi_idx_simple')
LIMIT 10;
NOTICE:  BM25 index scan: tid=(0,5), BM25_score=-1.2723
NOTICE:  BM25 index scan: tid=(0,1), BM25_score=-1.0118
NOTICE:  BM25 index scan: tid=(0,3), BM25_score=-0.5636
NOTICE:  BM25 index scan: tid=(0,4), BM25_score=-0.5059
 id |            content             | simple_score 
----+--------------------------------+--------------
  5 | hello database world           |      -1.2723
  1 | hello world from the test      |      -1.0118
  3 | hello from another document    |      -0.5636
  4 | world of databases and indexes |      -0.5059
(4 rows)

-- Verify both indexes exist and function independently
SELECT
    i.indexrelid::regclass as index_name,
    pg_size_pretty(pg_relation_size(i.indexrelid)) as index_size
FROM pg_index i
JOIN pg_class c ON c.oid = i.indrelid
WHERE c.relname = 'multi_idx_test'
ORDER BY index_name;
     index_name      | index_size 
---------------------+------------
 multi_idx_test_pkey | 16 kB
 multi_idx_english   | 16 kB
 multi_idx_simple    | 16 kB
(3 rows)

-- Clean up test table
DROP TABLE multi_idx_test CASCADE;
-- Final verification
\echo 'Final verification: Index statistics'
Final verification: Index statistics
SELECT
    'concurrent_test_docs' as table_name,
    COUNT(*) as total_docs,
    COUNT(DISTINCT content) as unique_docs
FROM concurrent_test_docs
UNION ALL
SELECT
    'concurrent_test_docs2' as table_name,
    COUNT(*) as total_docs,
    COUNT(DISTINCT content) as unique_docs
FROM concurrent_test_docs2;
      table_name       | total_docs | unique_docs 
-----------------------+------------+-------------
 concurrent_test_docs  |         52 |          50
 concurrent_test_docs2 |          5 |           5
(2 rows)

-- Clean up
DROP TABLE concurrent_test_docs CASCADE;
DROP TABLE concurrent_test_docs2 CASCADE;
DROP EXTENSION pg_textsearch CASCADE;
