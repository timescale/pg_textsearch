-- Additional coverage tests for untested code paths
-- Tests debug functions, segment dump, and text<@>text operator
CREATE EXTENSION IF NOT EXISTS pg_textsearch;
WARNING:  pg_textsearch v1.0.0-dev is a prerelease. Do not use in production.
-- =============================================================================
-- Test 1: Basic debug functions with memtable-only data
-- =============================================================================
-- Create a simple table and index
CREATE TABLE coverage_docs (id SERIAL PRIMARY KEY, content TEXT);
INSERT INTO coverage_docs (content) VALUES
    ('hello world test document'),
    ('database search query optimization'),
    ('full text search engine postgresql');
CREATE INDEX coverage_idx ON coverage_docs USING bm25(content)
    WITH (text_config='english');
NOTICE:  Using text search configuration: english
NOTICE:  Using index options: k1=1.20, b=0.75
NOTICE:  BM25 index build completed: 3 documents, avg_length=4.33, text_config='english' (k1=1.20, b=0.75)
-- Test bm25_summarize_index with memtable data
SELECT bm25_summarize_index('coverage_idx') IS NOT NULL AS summarize_memtable;
 summarize_memtable 
--------------------
 t
(1 row)

-- Test bm25_dump_index with memtable data
SELECT length(bm25_dump_index('coverage_idx')) > 0 AS dump_memtable;
 dump_memtable 
---------------
 t
(1 row)

-- =============================================================================
-- Test 2: Debug functions with segment data (exercises segment dump code)
-- =============================================================================
-- Force segment spill to have data on disk
-- Note: With build mode, data is already spilled during CREATE INDEX,
-- so memtable is empty here and returns NULL
SELECT bm25_spill_index('coverage_idx');
 bm25_spill_index 
------------------
                 
(1 row)

-- Test bm25_summarize_index with segment data
-- This exercises tp_summarize_index_to_output with segments
SELECT bm25_summarize_index('coverage_idx') IS NOT NULL AS summarize_segment;
 summarize_segment 
-------------------
 t
(1 row)

-- Test bm25_dump_index with segment data
-- This exercises tp_dump_segment_to_output, read_dict_entry, read_term_at_index
SELECT length(bm25_dump_index('coverage_idx')) > 0 AS dump_segment;
 dump_segment 
--------------
 t
(1 row)

-- =============================================================================
-- Test 3: bm25query equality (tpquery_eq)
-- =============================================================================
-- Test equality of identical queries
SELECT to_bm25query('hello', 'coverage_idx') = to_bm25query('hello', 'coverage_idx') AS same_query_eq;
 same_query_eq 
---------------
 t
(1 row)

-- Test inequality of different queries
SELECT to_bm25query('hello', 'coverage_idx') = to_bm25query('world', 'coverage_idx') AS diff_query_eq;
 diff_query_eq 
---------------
 f
(1 row)

-- =============================================================================
-- Test 4: text <@> text operator (bm25_text_text_score)
-- This is the implicit form without explicit bm25query
-- =============================================================================
-- Insert more data to create variation
INSERT INTO coverage_docs (content) VALUES
    ('additional text for testing'),
    ('more content with different words');
-- Test text <@> text implicit scoring
-- This uses find_first_child_index to locate the bm25 index
SET enable_seqscan = off;
-- The implicit form should find coverage_idx automatically
SELECT content, content <@> 'hello'::text AS score
FROM coverage_docs
WHERE content <@> 'hello'::text < 0
ORDER BY content <@> 'hello'::text
LIMIT 3;
          content          |        score        
---------------------------+---------------------
 hello world test document | -1.3570750951766968
(1 row)

SET enable_seqscan = on;
-- =============================================================================
-- Test 5: Multiple segments (exercises segment iteration in dump)
-- =============================================================================
-- Add more data and spill again to create multiple segments
INSERT INTO coverage_docs (content)
SELECT 'document number ' || i || ' with varying content for coverage'
FROM generate_series(1, 100) AS i;
SELECT bm25_spill_index('coverage_idx');
 bm25_spill_index 
------------------
                4
(1 row)

-- Dump with multiple segments
SELECT length(bm25_dump_index('coverage_idx')) > 0 AS dump_multi_segment;
 dump_multi_segment 
--------------------
 t
(1 row)

-- =============================================================================
-- Test 6: Page visualization (exercises dump.c pageviz code)
-- =============================================================================
-- bm25_debug_pageviz writes page layout to file
SELECT bm25_debug_pageviz('coverage_idx', '/tmp/test_pageviz.txt');
INFO:  Page visualization written to /tmp/test_pageviz.txt
  bm25_debug_pageviz   
-----------------------
 /tmp/test_pageviz.txt
(1 row)

-- Verify it wrote something
\! test -s /tmp/test_pageviz.txt && echo 'pageviz file exists'
pageviz file exists
-- Clean up temp file
\! rm -f /tmp/test_pageviz.txt
-- =============================================================================
-- Test 7: Score logging (exercises am/scan.c log_scores path)
-- =============================================================================
SET pg_textsearch.log_scores = true;
SELECT content <@> to_bm25query('hello', 'coverage_idx') AS score
FROM coverage_docs
WHERE content <@> to_bm25query('hello', 'coverage_idx') < 0
ORDER BY content <@> to_bm25query('hello', 'coverage_idx')
LIMIT 1;
NOTICE:  BM25 index scan: tid=(0,1), BM25_score=-4.9028
       score        
--------------------
 -4.902772426605225
(1 row)

SET pg_textsearch.log_scores = false;
-- =============================================================================
-- Test 8: BMW stats logging (exercises score.c bmw_stats path)
-- =============================================================================
SET pg_textsearch.log_bmw_stats = true;
-- Single-term query
SELECT count(*) FROM coverage_docs
WHERE content <@> to_bm25query('hello', 'coverage_idx') < 0;
 count 
-------
     1
(1 row)

-- Multi-term query
SELECT count(*) FROM coverage_docs
WHERE content <@> to_bm25query('hello world', 'coverage_idx') < 0;
 count 
-------
     1
(1 row)

SET pg_textsearch.log_bmw_stats = false;
-- =============================================================================
-- Test 9: AM handler property callbacks (exercises handler.c tp_property)
-- =============================================================================
-- Test pg_indexam_has_property for our access method
SELECT pg_indexam_has_property(am.oid, 'can_order') AS can_order,
       pg_indexam_has_property(am.oid, 'can_unique') AS can_unique
FROM pg_am am WHERE am.amname = 'bm25';
 can_order | can_unique 
-----------+------------
 f         | f
(1 row)

-- Test index-level properties
SELECT pg_index_has_property('coverage_idx'::regclass, 'clusterable') AS clusterable,
       pg_index_has_property('coverage_idx'::regclass, 'index_scan') AS index_scan;
 clusterable | index_scan 
-------------+------------
 f           | t
(1 row)

-- Test column-level property (distance_orderable triggers tp_property)
SELECT pg_index_column_has_property('coverage_idx'::regclass, 1,
    'distance_orderable') AS dist_orderable;
 dist_orderable 
----------------
 t
(1 row)

-- =============================================================================
-- Test 10: AM validate error path (exercises handler.c tp_validate)
-- =============================================================================
-- Try creating a bm25 index on integer column (should fail validation)
CREATE TABLE validate_test (id serial, num integer);
CREATE INDEX validate_test_idx ON validate_test USING bm25(num)
    WITH (text_config='english');
ERROR:  data type integer has no default operator class for access method "bm25"
HINT:  You must specify an operator class for the index or define a default operator class for the data type.
DROP TABLE validate_test;
-- =============================================================================
-- Test 11: bm25_dump_index to file (exercises file output path)
-- =============================================================================
SELECT bm25_dump_index('coverage_idx', '/tmp/test_dump.txt') IS NOT NULL
    AS dump_to_file;
INFO:  Index dump written to /tmp/test_dump.txt
 dump_to_file 
--------------
 t
(1 row)

\! test -s /tmp/test_dump.txt && echo 'dump file exists'
dump file exists
\! rm -f /tmp/test_dump.txt
-- =============================================================================
-- Cleanup
-- =============================================================================
DROP TABLE coverage_docs CASCADE;
DROP EXTENSION pg_textsearch CASCADE;
