-- Test memtable spilling to segments using tp_spill_memtable()
-- This test verifies that forced spills work correctly with small datasets
CREATE EXTENSION IF NOT EXISTS pg_textsearch;
INFO:  pg_textsearch v0.0.3-dev: This is prerelease software and should not be used in production.
SET pg_textsearch.log_scores = true;
SET enable_seqscan = off;
-- Test 1: Basic spill with small dataset
DROP TABLE IF EXISTS spill_basic CASCADE;
NOTICE:  table "spill_basic" does not exist, skipping
CREATE TABLE spill_basic (id INT PRIMARY KEY, doc TEXT);
CREATE INDEX spill_basic_idx ON spill_basic USING bm25(doc)
  WITH (text_config='english');
NOTICE:  BM25 index build started for relation spill_basic_idx
NOTICE:  Using text search configuration: english
NOTICE:  Using index options: k1=1.20, b=0.75
NOTICE:  BM25 index build completed: 0 documents, avg_length=0.00, text_config='english' (k1=1.20, b=0.75)
INSERT INTO spill_basic VALUES
  (1, 'hello world'),
  (2, 'goodbye world'),
  (3, 'test document');
-- Query before spill
SELECT id, ROUND((doc <@> to_bm25query('world', 'spill_basic_idx'))::numeric, 4)
  as score
FROM spill_basic
ORDER BY doc <@> to_bm25query('world', 'spill_basic_idx');
NOTICE:  BM25 index scan: tid=(0,2), BM25_score=-0.0766
NOTICE:  BM25 index scan: tid=(0,1), BM25_score=-0.0766
NOTICE:  BM25 index scan: tid=(0,3), BM25_score=0.0000
 id |  score  
----+---------
  2 | -0.0766
  1 | -0.0766
  3 |  0.0000
(3 rows)

-- Force memtable spill
SELECT tp_spill_memtable('spill_basic_idx');
       tp_spill_memtable       
-------------------------------
 Memtable flushed successfully
(1 row)

-- Query after spill - should still work
SELECT id, ROUND((doc <@> to_bm25query('world', 'spill_basic_idx'))::numeric, 4)
  as score
FROM spill_basic
ORDER BY doc <@> to_bm25query('world', 'spill_basic_idx');
WARNING:  resource was not closed: [5191] (rel=base/1972982/1973021, blockNum=2, flags=0x93800000, refcount=1 2)
WARNING:  resource was not closed: [5191] (rel=base/1972982/1973021, blockNum=2, flags=0x93800000, refcount=1 1)
 id | score 
----+-------
(0 rows)

-- Test 2: Spill with updates
DROP TABLE IF EXISTS spill_update CASCADE;
NOTICE:  table "spill_update" does not exist, skipping
CREATE TABLE spill_update (id INT PRIMARY KEY, doc TEXT);
CREATE INDEX spill_update_idx ON spill_update USING bm25(doc)
  WITH (text_config='english');
NOTICE:  BM25 index build started for relation spill_update_idx
NOTICE:  Using text search configuration: english
NOTICE:  Using index options: k1=1.20, b=0.75
NOTICE:  BM25 index build completed: 0 documents, avg_length=0.00, text_config='english' (k1=1.20, b=0.75)
INSERT INTO spill_update VALUES
  (1, 'original document one'),
  (2, 'original document two');
-- Force spill
SELECT tp_spill_memtable('spill_update_idx');
       tp_spill_memtable       
-------------------------------
 Memtable flushed successfully
(1 row)

-- Add more documents after spill
INSERT INTO spill_update VALUES
  (3, 'new document three'),
  (4, 'new document four');
-- Query should work across both memtable and segment
SELECT id, ROUND((doc <@> to_bm25query('document', 'spill_update_idx'))::numeric, 4)
  as score
FROM spill_update
ORDER BY doc <@> to_bm25query('document', 'spill_update_idx');
WARNING:  resource was not closed: [5197] (rel=base/1972982/1973029, blockNum=2, flags=0x93800000, refcount=1 2)
WARNING:  resource was not closed: [5197] (rel=base/1972982/1973029, blockNum=2, flags=0x93800000, refcount=1 1)
 id | score 
----+-------
(0 rows)

-- Test 3: Multiple spills
DROP TABLE IF EXISTS spill_multiple CASCADE;
NOTICE:  table "spill_multiple" does not exist, skipping
CREATE TABLE spill_multiple (id INT PRIMARY KEY, doc TEXT);
CREATE INDEX spill_multiple_idx ON spill_multiple USING bm25(doc)
  WITH (text_config='english');
NOTICE:  BM25 index build started for relation spill_multiple_idx
NOTICE:  Using text search configuration: english
NOTICE:  Using index options: k1=1.20, b=0.75
NOTICE:  BM25 index build completed: 0 documents, avg_length=0.00, text_config='english' (k1=1.20, b=0.75)
-- First batch
INSERT INTO spill_multiple VALUES (1, 'first batch document');
SELECT tp_spill_memtable('spill_multiple_idx');
       tp_spill_memtable       
-------------------------------
 Memtable flushed successfully
(1 row)

-- Second batch
INSERT INTO spill_multiple VALUES (2, 'second batch document');
SELECT tp_spill_memtable('spill_multiple_idx');
       tp_spill_memtable       
-------------------------------
 Memtable flushed successfully
(1 row)

-- Third batch
INSERT INTO spill_multiple VALUES (3, 'third batch document');
-- Query across all three (two segments + memtable)
SELECT id, ROUND((doc <@> to_bm25query('document', 'spill_multiple_idx'))::numeric, 4)
  as score
FROM spill_multiple
ORDER BY doc <@> to_bm25query('document', 'spill_multiple_idx');
WARNING:  resource was not closed: [5205] (rel=base/1972982/1973037, blockNum=3, flags=0x93800000, refcount=1 2)
WARNING:  resource was not closed: [5205] (rel=base/1972982/1973037, blockNum=3, flags=0x93800000, refcount=1 1)
 id | score 
----+-------
(0 rows)

-- Test 4: Spill with different query terms
DROP TABLE IF EXISTS spill_terms CASCADE;
NOTICE:  table "spill_terms" does not exist, skipping
CREATE TABLE spill_terms (id INT PRIMARY KEY, doc TEXT);
CREATE INDEX spill_terms_idx ON spill_terms USING bm25(doc)
  WITH (text_config='english');
NOTICE:  BM25 index build started for relation spill_terms_idx
NOTICE:  Using text search configuration: english
NOTICE:  Using index options: k1=1.20, b=0.75
NOTICE:  BM25 index build completed: 0 documents, avg_length=0.00, text_config='english' (k1=1.20, b=0.75)
INSERT INTO spill_terms VALUES
  (1, 'apple banana cherry'),
  (2, 'date elderberry fig');
SELECT tp_spill_memtable('spill_terms_idx');
       tp_spill_memtable       
-------------------------------
 Memtable flushed successfully
(1 row)

INSERT INTO spill_terms VALUES
  (3, 'grape honeydew apple'),
  (4, 'kiwi lemon mango');
-- Query for term in segment only
SELECT id, doc, ROUND((doc <@> to_bm25query('banana', 'spill_terms_idx'))::numeric, 4)
  as score
FROM spill_terms
WHERE doc <@> to_bm25query('banana', 'spill_terms_idx') < 0
ORDER BY doc <@> to_bm25query('banana', 'spill_terms_idx');
WARNING:  resource was not closed: [5212] (rel=base/1972982/1973045, blockNum=2, flags=0x93800000, refcount=1 2)
WARNING:  resource was not closed: [5212] (rel=base/1972982/1973045, blockNum=2, flags=0x93800000, refcount=1 1)
 id | doc | score 
----+-----+-------
(0 rows)

-- Query for term in memtable only
SELECT id, doc, ROUND((doc <@> to_bm25query('kiwi', 'spill_terms_idx'))::numeric, 4)
  as score
FROM spill_terms
WHERE doc <@> to_bm25query('kiwi', 'spill_terms_idx') < 0
ORDER BY doc <@> to_bm25query('kiwi', 'spill_terms_idx');
PANIC:  ERRORDATA_STACK_SIZE exceeded
server closed the connection unexpectedly
	This probably means the server terminated abnormally
	before or while processing the request.
connection to server was lost
