-- Test tpvector type and operators functionality
-- Load tapir extension
CREATE EXTENSION IF NOT EXISTS tapir;
-- Enable score logging for testing
SET tapir.log_scores = true;
SET client_min_messages = NOTICE;
SET enable_seqscan = false;
-- Cleanup any existing state first
DROP TABLE IF EXISTS test_docs CASCADE;
NOTICE:  table "test_docs" does not exist, skipping
-- Setup test table
CREATE TABLE test_docs (
    id SERIAL PRIMARY KEY,
    content TEXT
);
INSERT INTO test_docs (content) VALUES
    ('the quick brown fox'),
    ('jumped over the lazy dog'),
    ('sphinx of black quartz'),
    ('hello world example'),
    ('postgresql full text search');
-- Create tapir index
CREATE INDEX docs_vector_idx ON test_docs USING tapir(content) WITH (text_config='english');
NOTICE:  Tapir index build started for relation docs_vector_idx
NOTICE:  Using text search configuration: english
NOTICE:  Using index options: k1=1.20, b=0.75
NOTICE:  Tapir index build completed: 5 documents, avg_length=3.20, text_config='english' (k1=1.20, b=0.75)
-- Test tpvector I/O functions
-- Test input/output with index name format
SELECT 'docs_vector_idx:{hello:2,world:1}'::tpvector;
             tpvector              
-----------------------------------
 docs_vector_idx:{hello:2,world:1}
(1 row)

SELECT 'docs_vector_idx:{}'::tpvector;
      tpvector      
--------------------
 docs_vector_idx:{}
(1 row)

-- Test to_tpvector function
SELECT to_tpvector('hello world', 'docs_vector_idx');
            to_tpvector            
-----------------------------------
 docs_vector_idx:{hello:1,world:1}
(1 row)

SELECT to_tpvector('postgresql search', 'docs_vector_idx');
               to_tpvector               
-----------------------------------------
 docs_vector_idx:{postgresql:1,search:1}
(1 row)

-- Test to_tpvector edge cases
SELECT to_tpvector('', 'docs_vector_idx');  -- empty text
    to_tpvector     
--------------------
 docs_vector_idx:{}
(1 row)

SELECT to_tpvector('hello, world! How are you? I''m fine.', 'docs_vector_idx');  -- punctuation
                 to_tpvector                  
----------------------------------------------
 docs_vector_idx:{fine:1,hello:1,m:1,world:1}
(1 row)

SELECT to_tpvector('Testing 123 with numbers and text', 'docs_vector_idx');  -- numbers
                  to_tpvector                   
------------------------------------------------
 docs_vector_idx:{123:1,number:1,test:1,text:1}
(1 row)

-- Test that different queries create different vectors
SELECT to_tpvector('hello', 'docs_vector_idx') = to_tpvector('world', 'docs_vector_idx');
 ?column? 
----------
 f
(1 row)

-- Test error cases (tpvector <@> tpvector operator removed for consistency)
-- Test nonexistent index error
\set VERBOSITY terse
\set ON_ERROR_STOP off
SELECT to_tpvector('test text', 'nonexistent_index');
ERROR:  index "nonexistent_index" does not exist
\set ON_ERROR_STOP on
\set VERBOSITY default
-- Test tapir scoring using standalone text <@> tpquery operations
SELECT
    content,
    ROUND((content <@> to_tpquery('hello world', 'docs_vector_idx'))::numeric, 4) as score
FROM test_docs
ORDER BY score;
           content           |  score  
-----------------------------+---------
 hello world example         | -2.2549
 the quick brown fox         |  0.0000
 jumped over the lazy dog    |  0.0000
 sphinx of black quartz      |  0.0000
 postgresql full text search |  0.0000
(5 rows)

-- Test different query terms with standalone text <@> tpquery operations
SELECT
    content,
    ROUND((content <@> to_tpquery('postgresql', 'docs_vector_idx'))::numeric, 4) as postgresql_score,
    ROUND((content <@> to_tpquery('search', 'docs_vector_idx'))::numeric, 4) as search_score
FROM test_docs
ORDER BY (content <@> to_tpquery('postgresql', 'docs_vector_idx'))::float8 +
         (content <@> to_tpquery('search', 'docs_vector_idx'))::float8;
           content           | postgresql_score | search_score 
-----------------------------+------------------+--------------
 postgresql full text search |          -0.9967 |      -0.9967
 the quick brown fox         |           0.0000 |       0.0000
 jumped over the lazy dog    |           0.0000 |       0.0000
 sphinx of black quartz      |           0.0000 |       0.0000
 hello world example         |           0.0000 |       0.0000
(5 rows)

-- Test vector serialization/deserialization
SELECT to_tpvector('hello', 'docs_vector_idx')::text;
        to_tpvector        
---------------------------
 docs_vector_idx:{hello:1}
(1 row)

SELECT to_tpvector('test word', 'docs_vector_idx')::text;
           to_tpvector           
---------------------------------
 docs_vector_idx:{test:1,word:1}
(1 row)

-- Test with longer text
SELECT to_tpvector('this is a longer test with multiple words and repetitions test test', 'docs_vector_idx');
                         to_tpvector                          
--------------------------------------------------------------
 docs_vector_idx:{longer:1,multipl:1,repetit:1,test:3,word:1}
(1 row)

-- Test tpvector equality operator
SELECT
    to_tpvector('hello world', 'docs_vector_idx') = to_tpvector('hello world', 'docs_vector_idx') as should_be_true,
    to_tpvector('hello world', 'docs_vector_idx') = to_tpvector('world hello', 'docs_vector_idx') as depends_on_order;
 should_be_true | depends_on_order 
----------------+------------------
 t              | t
(1 row)

-- Test direct tpvector equality (including order-independence fix)
SELECT 'docs_vector_idx:{hello:1,world:2}'::tpvector = 'docs_vector_idx:{hello:1,world:2}'::tpvector;
 ?column? 
----------
 t
(1 row)

SELECT 'docs_vector_idx:{hello:1,world:2}'::tpvector = 'docs_vector_idx:{world:2,hello:1}'::tpvector;
 ?column? 
----------
 t
(1 row)

-- Test scoring with real documents
SELECT
    id,
    content,
    ROUND((content <@> to_tpquery('quick fox', 'docs_vector_idx'))::numeric, 4) as relevance
FROM test_docs
ORDER BY content <@> to_tpquery('quick fox', 'docs_vector_idx')  -- BM25 scoring for ranking
LIMIT 3;
NOTICE:  Tapir index scan: doc_pos=0, tid=(0,1), BM25_score=-2.2549
NOTICE:  Tapir index scan: doc_pos=1, tid=(0,2), BM25_score=-0.0000
NOTICE:  Tapir index scan: doc_pos=2, tid=(0,3), BM25_score=-0.0000
 id |         content          | relevance 
----+--------------------------+-----------
  1 | the quick brown fox      |   -2.2549
  2 | jumped over the lazy dog |    0.0000
  3 | sphinx of black quartz   |    0.0000
(3 rows)

-- Test with another index using simple config
CREATE INDEX docs_simple_idx ON test_docs USING tapir(content) WITH (text_config='simple');
NOTICE:  Tapir index build started for relation docs_simple_idx
NOTICE:  Using text search configuration: simple
NOTICE:  Using index options: k1=1.20, b=0.75
NOTICE:  Tapir index build completed: 5 documents, avg_length=4.00, text_config='simple' (k1=1.20, b=0.75)
-- Compare stemmed vs non-stemmed
SELECT
    'running' as query,
    to_tpvector('running runner runs', 'docs_vector_idx') as english_stemmed,
    to_tpvector('running runner runs', 'docs_simple_idx') as simple_no_stem;
  query  |         english_stemmed          |               simple_no_stem                
---------+----------------------------------+---------------------------------------------
 running | docs_vector_idx:{run:2,runner:1} | docs_simple_idx:{runner:1,running:1,runs:1}
(1 row)

-- Test scoring consistency: ORDER BY vs standalone scoring
\echo 'Testing ORDER BY vs standalone scoring consistency'
Testing ORDER BY vs standalone scoring consistency
WITH order_by_scores AS (
    SELECT id, content,
           ROUND((content <@> to_tpquery('fox dog', 'docs_simple_idx'))::numeric, 6) as order_by_score
    FROM test_docs
    ORDER BY content <@> to_tpquery('fox dog', 'docs_simple_idx')
    LIMIT 3
),
standalone_scores AS (
    -- Force standalone scoring by using all documents and calculating scores explicitly
    SELECT id, content,
           ROUND((content <@> to_tpquery('fox dog', 'docs_simple_idx'))::numeric, 6) as standalone_score
    FROM test_docs
    -- No WHERE clause to force sequential scan and standalone scoring for all rows
)
SELECT o.id,
       o.order_by_score,
       s.standalone_score,
       CASE WHEN abs(o.order_by_score - s.standalone_score) < 0.000001
            THEN '✓ SCORES MATCH'
            ELSE '✗ SCORES DIFFER'
       END as score_consistency
FROM order_by_scores o
JOIN standalone_scores s ON o.id = s.id
ORDER BY o.id;
NOTICE:  Tapir index scan: doc_pos=0, tid=(0,1), BM25_score=-1.0986
NOTICE:  Tapir index scan: doc_pos=1, tid=(0,2), BM25_score=-0.9967
NOTICE:  Tapir index scan: doc_pos=2, tid=(0,3), BM25_score=-0.0000
 id | order_by_score | standalone_score | score_consistency 
----+----------------+------------------+-------------------
  1 |      -1.098612 |        -1.098612 | ✓ SCORES MATCH
  2 |      -0.996679 |        -0.996679 | ✓ SCORES MATCH
  3 |       0.000000 |         0.000000 | ✓ SCORES MATCH
(3 rows)

-- Cleanup
DROP INDEX docs_vector_idx;
DROP INDEX docs_simple_idx;
DROP TABLE test_docs;
DROP EXTENSION tapir CASCADE;
