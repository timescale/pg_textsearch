-- Test bm25vector type and operators functionality
-- Load pg_textsearch extension
CREATE EXTENSION IF NOT EXISTS pg_textsearch;
INFO:  pg_textsearch v0.0.6: This is prerelease software and should not be used in production.
INFO:  This release contains breaking changes in the bm25 index structure and will require existing indexes to be rebuilt.
-- Enable score logging for testing
SET pg_textsearch.log_scores = true;
SET client_min_messages = NOTICE;
SET enable_seqscan = false;
-- Cleanup any existing state first
DROP TABLE IF EXISTS test_docs CASCADE;
NOTICE:  table "test_docs" does not exist, skipping
-- Setup test table
CREATE TABLE test_docs (
    id SERIAL PRIMARY KEY,
    content TEXT
);
INSERT INTO test_docs (content) VALUES
    ('the quick brown fox'),
    ('jumped over the lazy dog'),
    ('sphinx of black quartz'),
    ('hello world example'),
    ('postgresql full text search');
-- Create pg_textsearch index
CREATE INDEX docs_vector_idx ON test_docs USING bm25(content) WITH (text_config='english');
NOTICE:  BM25 index build started for relation docs_vector_idx
NOTICE:  Using text search configuration: english
NOTICE:  Using index options: k1=1.20, b=0.75
NOTICE:  BM25 index build completed: 5 documents, avg_length=3.20, text_config='english' (k1=1.20, b=0.75)
-- Test bm25vector I/O functions
-- Test input/output with index name format
SELECT 'docs_vector_idx:{hello:2,world:1}'::bm25vector;
            bm25vector             
-----------------------------------
 docs_vector_idx:{hello:2,world:1}
(1 row)

SELECT 'docs_vector_idx:{}'::bm25vector;
     bm25vector     
--------------------
 docs_vector_idx:{}
(1 row)

-- Test pg_textsearch scoring using text <@> bm25query operations
-- Note: Uses to_bm25query since ORDER BY is on alias not directly on operator
SELECT
    content,
    ROUND((content <@> to_bm25query('hello world', 'docs_vector_idx'))::numeric, 4) as score
FROM test_docs
ORDER BY score;
           content           |  score  
-----------------------------+---------
 hello world example         | -2.8453
 the quick brown fox         |  0.0000
 jumped over the lazy dog    |  0.0000
 sphinx of black quartz      |  0.0000
 postgresql full text search |  0.0000
(5 rows)

-- Test different query terms with standalone text <@> bm25query operations
-- Note: Uses explicit index name because ORDER BY is on sum of two operators
SELECT
    content,
    ROUND((content <@> to_bm25query('postgresql', 'docs_vector_idx'))::numeric, 4) as postgresql_score,
    ROUND((content <@> to_bm25query('search', 'docs_vector_idx'))::numeric, 4) as search_score
FROM test_docs
ORDER BY (content <@> to_bm25query('postgresql', 'docs_vector_idx'))::float8 +
         (content <@> to_bm25query('search', 'docs_vector_idx'))::float8;
           content           | postgresql_score | search_score 
-----------------------------+------------------+--------------
 postgresql full text search |          -1.2577 |      -1.2577
 the quick brown fox         |           0.0000 |       0.0000
 jumped over the lazy dog    |           0.0000 |       0.0000
 sphinx of black quartz      |           0.0000 |       0.0000
 hello world example         |           0.0000 |       0.0000
(5 rows)

-- Test bm25vector equality operator
SELECT 'docs_vector_idx:{hello:1,world:2}'::bm25vector = 'docs_vector_idx:{hello:1,world:2}'::bm25vector;
 ?column? 
----------
 t
(1 row)

SELECT 'docs_vector_idx:{hello:1,world:2}'::bm25vector = 'docs_vector_idx:{world:2,hello:1}'::bm25vector;
 ?column? 
----------
 t
(1 row)

-- Test scoring with real documents
SELECT
    id,
    content,
    ROUND((content <@> to_bm25query('quick fox', 'docs_vector_idx'))::numeric, 4) as relevance
FROM test_docs
ORDER BY content <@> to_bm25query('quick fox', 'docs_vector_idx')  -- BM25 scoring for ranking
LIMIT 3;
NOTICE:  BM25 index scan: tid=(0,1), BM25_score=-2.8453
 id |       content       | relevance 
----+---------------------+-----------
  1 | the quick brown fox |   -2.8453
(1 row)

-- Test with another index using simple config
CREATE INDEX docs_simple_idx ON test_docs USING bm25(content) WITH (text_config='simple');
NOTICE:  BM25 index build started for relation docs_simple_idx
NOTICE:  Using text search configuration: simple
NOTICE:  Using index options: k1=1.20, b=0.75
NOTICE:  BM25 index build completed: 5 documents, avg_length=4.00, text_config='simple' (k1=1.20, b=0.75)
-- Test scoring consistency: ORDER BY vs standalone scoring
\echo 'Testing ORDER BY vs standalone scoring consistency'
Testing ORDER BY vs standalone scoring consistency
WITH order_by_scores AS (
    SELECT id, content,
           ROUND((content <@> to_bm25query('fox dog', 'docs_simple_idx'))::numeric, 6) as order_by_score
    FROM test_docs
    ORDER BY content <@> to_bm25query('fox dog', 'docs_simple_idx')
    LIMIT 3
),
standalone_scores AS (
    -- Force standalone scoring by using all documents and calculating scores explicitly
    SELECT id, content,
           ROUND((content <@> to_bm25query('fox dog', 'docs_simple_idx'))::numeric, 6) as standalone_score
    FROM test_docs
    -- No WHERE clause to force sequential scan and standalone scoring for all rows
)
SELECT o.id,
       o.order_by_score,
       s.standalone_score,
       CASE WHEN abs(o.order_by_score - s.standalone_score) < 0.000001
            THEN '✓ SCORES MATCH'
            ELSE '✗ SCORES DIFFER'
       END as score_consistency
FROM order_by_scores o
JOIN standalone_scores s ON o.id = s.id
ORDER BY o.id;
NOTICE:  BM25 index scan: tid=(0,1), BM25_score=-1.3863
NOTICE:  BM25 index scan: tid=(0,2), BM25_score=-1.2577
 id | order_by_score | standalone_score | score_consistency 
----+----------------+------------------+-------------------
  1 |      -1.386294 |        -1.386294 | ✓ SCORES MATCH
  2 |      -1.257669 |        -1.257669 | ✓ SCORES MATCH
(2 rows)

-- Cleanup
DROP INDEX docs_vector_idx;
DROP INDEX docs_simple_idx;
DROP TABLE test_docs;
DROP EXTENSION pg_textsearch CASCADE;
