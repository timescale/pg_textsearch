-- Test pg_textsearch index access method functionality
-- Load pg_textsearch extension
CREATE EXTENSION IF NOT EXISTS pg_textsearch;
INFO:  pg_textsearch v0.0.1: This is prerelease software and should not be used in production.
-- Enable score logging for testing
SET pg_textsearch.log_scores = true;
-- Setup test table
CREATE TABLE test_docs (
    id SERIAL PRIMARY KEY,
    content TEXT
);
ERROR:  relation "test_docs" already exists
INSERT INTO test_docs (content) VALUES
    ('the quick brown fox'),
    ('jumped over the lazy dog'),
    ('sphinx of black quartz'),
    ('hello world example'),
    ('postgresql full text search');
-- Test index creation with different text_config options
CREATE INDEX docs_english_idx ON test_docs USING bm25(content) WITH (text_config='english');
NOTICE:  Tapir index build started for relation docs_english_idx
NOTICE:  Using text search configuration: english
NOTICE:  Using index options: k1=1.20, b=0.75
ERROR:  too many dynamic shared memory segments
CREATE INDEX docs_simple_idx ON test_docs USING bm25(content) WITH (text_config='simple', k1=1.5, b=0.8);
NOTICE:  Tapir index build started for relation docs_simple_idx
NOTICE:  Using text search configuration: simple
NOTICE:  Using index options: k1=1.50, b=0.80
ERROR:  too many dynamic shared memory segments
-- Verify indexes were created
\d+ test_docs
                                                 Table "public.test_docs"
 Column  |  Type   | Collation | Nullable |                Default                | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------------------------------------+----------+--------------+-------------
 id      | integer |           | not null | nextval('test_docs_id_seq'::regclass) | plain    |              | 
 content | text    |           |          |                                       | extended |              | 
Indexes:
    "test_docs_pkey" PRIMARY KEY, btree (id)

-- Test basic index operations
INSERT INTO test_docs (content) VALUES ('new document for testing');
-- Test that to_bm25vector works with our indexes
SELECT to_bm25vector('test document content', 'docs_english_idx');
ERROR:  index "docs_english_idx" not found
SELECT to_bm25vector('test document content', 'docs_simple_idx');
ERROR:  index "docs_simple_idx" not found
-- Test that index options are correctly stored and retrievable
SELECT
    i.relname as index_name,
    CASE
        WHEN i.reloptions IS NOT NULL THEN 'has_options'
        ELSE 'no_options'
    END as options_status
FROM pg_class i
WHERE i.relname IN ('docs_english_idx', 'docs_simple_idx')
ORDER BY i.relname;
 index_name | options_status 
------------+----------------
(0 rows)

-- Test vectorization with both indexes
SELECT
    'docs_english_idx' as index_name,
    to_bm25vector('postgresql database system', 'docs_english_idx') as vector;
ERROR:  index "docs_english_idx" not found
SELECT
    'docs_simple_idx' as index_name,
    to_bm25vector('postgresql database system', 'docs_simple_idx') as vector;
ERROR:  index "docs_simple_idx" not found
-- Cleanup
DROP INDEX docs_english_idx;
ERROR:  index "docs_english_idx" does not exist
DROP INDEX docs_simple_idx;
ERROR:  index "docs_simple_idx" does not exist
DROP TABLE test_docs;
ERROR:  requested DSM segment size does not match size of existing segment
DROP EXTENSION pg_textsearch CASCADE;
