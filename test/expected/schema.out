-- Test case: schema
-- Tests index operations with schema-qualified tables
CREATE EXTENSION IF NOT EXISTS pg_textsearch;
INFO:  pg_textsearch v0.0.5-dev: This is prerelease software and should not be used in production.
INFO:  This release contains breaking changes in the bm25 index structure and will require existing indexes to be rebuilt.
SET pg_textsearch.log_scores = true;
SET enable_seqscan = off;
-- Create a custom schema
CREATE SCHEMA docs;
-- Create table in the custom schema
CREATE TABLE docs.articles (
    id SERIAL PRIMARY KEY,
    content TEXT
);
-- Insert test documents
INSERT INTO docs.articles (content) VALUES ('hello world');
INSERT INTO docs.articles (content) VALUES ('goodbye cruel world');
INSERT INTO docs.articles (content) VALUES ('hello cruel goodbye');
-- Create index on schema-qualified table
CREATE INDEX articles_idx ON docs.articles USING bm25(content)
  WITH (text_config='english', k1=1.2, b=0.75);
NOTICE:  BM25 index build started for relation articles_idx
NOTICE:  Using text search configuration: english
NOTICE:  Using index options: k1=1.20, b=0.75
NOTICE:  BM25 index build completed: 3 documents, avg_length=2.67, text_config='english' (k1=1.20, b=0.75)
-- Test 1: Unqualified index name (not in search path - should fail)
SELECT id, content, ROUND((content <@> to_bm25query('hello', 'articles_idx'))::numeric, 4) as score
FROM docs.articles
ORDER BY content <@> to_bm25query('hello', 'articles_idx'), id;
NOTICE:  BM25 index scan: tid=(0,1), BM25_score=-0.5235
ERROR:  index "articles_idx" not found
-- Test 2: Schema-qualified index name works correctly
SELECT id, content, ROUND((content <@> to_bm25query('hello', 'docs.articles_idx'))::numeric, 4) as score
FROM docs.articles
ORDER BY content <@> to_bm25query('hello', 'docs.articles_idx'), id;
NOTICE:  BM25 index scan: tid=(0,1), BM25_score=-0.5235
NOTICE:  BM25 index scan: tid=(0,3), BM25_score=-0.4471
NOTICE:  BM25 index scan: tid=(0,2), BM25_score=0.0000
 id |       content       |  score  
----+---------------------+---------
  1 | hello world         | -0.5235
  3 | hello cruel goodbye | -0.4471
  2 | goodbye cruel world |  0.0000
(3 rows)

-- Test 3: With search_path set, unqualified names work
SET search_path = docs, public;
SELECT id, content, ROUND((content <@> to_bm25query('hello', 'articles_idx'))::numeric, 4) as score
FROM articles
ORDER BY content <@> to_bm25query('hello', 'articles_idx'), id;
NOTICE:  BM25 index scan: tid=(0,1), BM25_score=-0.5235
NOTICE:  BM25 index scan: tid=(0,3), BM25_score=-0.4471
NOTICE:  BM25 index scan: tid=(0,2), BM25_score=0.0000
 id |       content       |  score  
----+---------------------+---------
  1 | hello world         | -0.5235
  3 | hello cruel goodbye | -0.4471
  2 | goodbye cruel world |  0.0000
(3 rows)

-- Reset search_path
SET search_path = public;
-- Test 4: Table in public schema works with unqualified names
CREATE TABLE public_articles (
    id SERIAL PRIMARY KEY,
    content TEXT
);
INSERT INTO public_articles (content) VALUES ('hello world');
INSERT INTO public_articles (content) VALUES ('goodbye cruel world');
CREATE INDEX public_articles_idx ON public_articles USING bm25(content)
  WITH (text_config='english', k1=1.2, b=0.75);
NOTICE:  BM25 index build started for relation public_articles_idx
NOTICE:  Using text search configuration: english
NOTICE:  Using index options: k1=1.20, b=0.75
NOTICE:  BM25 index build completed: 2 documents, avg_length=2.50, text_config='english' (k1=1.20, b=0.75)
-- Unqualified index name works for public schema tables
SELECT id, content, ROUND((content <@> to_bm25query('hello', 'public_articles_idx'))::numeric, 4) as score
FROM public_articles
ORDER BY content <@> to_bm25query('hello', 'public_articles_idx'), id;
NOTICE:  BM25 index scan: tid=(0,1), BM25_score=-0.7549
NOTICE:  BM25 index scan: tid=(0,2), BM25_score=0.0000
 id |       content       |  score  
----+---------------------+---------
  1 | hello world         | -0.7549
  2 | goodbye cruel world |  0.0000
(2 rows)

-- Test 5: INSERT operations with schema-qualified tables and implicit index
-- names (reproduces the reported bug)
CREATE SCHEMA bar;
CREATE TABLE bar.baz(content TEXT NOT NULL);
-- Create index with implicit name (PostgreSQL will name it baz_content_idx)
CREATE INDEX ON bar.baz USING bm25(content)
  WITH (text_config='english');
NOTICE:  BM25 index build started for relation baz_content_idx
NOTICE:  Using text search configuration: english
NOTICE:  Using index options: k1=1.20, b=0.75
NOTICE:  BM25 index build completed: 0 documents, avg_length=0.00, text_config='english' (k1=1.20, b=0.75)
-- This INSERT should work but currently fails with "index not found"
INSERT INTO bar.baz VALUES('really');
INSERT INTO bar.baz VALUES('testing schemas');
INSERT INTO bar.baz VALUES('another document');
-- Verify data was inserted correctly
SELECT * FROM bar.baz ORDER BY content;
     content      
------------------
 another document
 really
 testing schemas
(3 rows)

-- Test search functionality
SELECT content, ROUND((content <@> to_bm25query('testing',
  'bar.baz_content_idx'))::numeric, 4) as score
FROM bar.baz
ORDER BY content <@> to_bm25query('testing', 'bar.baz_content_idx'), content;
NOTICE:  BM25 index scan: tid=(0,2), BM25_score=-0.9066
NOTICE:  BM25 index scan: tid=(0,1), BM25_score=0.0000
NOTICE:  BM25 index scan: tid=(0,3), BM25_score=0.0000
     content      |  score  
------------------+---------
 testing schemas  | -0.9066
 another document |  0.0000
 really           |  0.0000
(3 rows)

-- Test BM25 edge case: With only 2 documents where a term appears in exactly
-- 50% of them (1 out of 2), the IDF becomes log(1) = 0, making the entire
-- BM25 score 0 regardless of term frequency. This is mathematically correct
-- behavior, not a bug.
CREATE SCHEMA edge_case;
CREATE TABLE edge_case.demo(content TEXT NOT NULL);
CREATE INDEX ON edge_case.demo USING bm25(content) WITH (text_config='english');
NOTICE:  BM25 index build started for relation demo_content_idx
NOTICE:  Using text search configuration: english
NOTICE:  Using index options: k1=1.20, b=0.75
NOTICE:  BM25 index build completed: 0 documents, avg_length=0.00, text_config='english' (k1=1.20, b=0.75)
-- Insert exactly 2 documents, one with "testing"
INSERT INTO edge_case.demo VALUES('really');
INSERT INTO edge_case.demo VALUES('testing schemas');
-- With 2 docs and "testing" in 1 (50%), IDF = log((2-1+0.5)/(1+0.5)) = log(1) = 0
SELECT content, ROUND((content <@> to_bm25query('testing',
  'edge_case.demo_content_idx'))::numeric, 4) as score
FROM edge_case.demo
ORDER BY content <@> to_bm25query('testing', 'edge_case.demo_content_idx'), content;
NOTICE:  BM25 index scan: tid=(0,2), BM25_score=-0.6100
NOTICE:  BM25 index scan: tid=(0,1), BM25_score=0.0000
     content     |  score  
-----------------+---------
 testing schemas | -0.6100
 really          |  0.0000
(2 rows)

DROP TABLE edge_case.demo CASCADE;
DROP SCHEMA edge_case CASCADE;
-- Test 6: bm25_dump_index with schema-qualified indexes
-- Test that the debug function properly handles schema resolution
-- Test debug with public schema index (should work)
SELECT bm25_dump_index('public_articles_idx')::text ~ 'Tapir Index Debug: public_articles_idx' AS debug_public_works;
 debug_public_works 
--------------------
 t
(1 row)

-- Test debug with schema-qualified index name (should work)
SELECT bm25_dump_index('bar.baz_content_idx')::text ~ 'Tapir Index Debug: bar.baz_content_idx' AS debug_schema_qualified;
 debug_schema_qualified 
------------------------
 t
(1 row)

-- Test debug with unqualified name for schema index (should fail when not in search path)
SELECT bm25_dump_index('baz_content_idx')::text ~ 'ERROR: Index ''baz_content_idx'' not found' AS debug_unqualified_fails;
 debug_unqualified_fails 
-------------------------
 t
(1 row)

-- Test debug with search_path set
SET search_path = bar, public;
SELECT bm25_dump_index('baz_content_idx')::text ~ 'Tapir Index Debug: baz_content_idx' AS debug_with_search_path;
 debug_with_search_path 
------------------------
 t
(1 row)

-- Reset search_path
SET search_path = public;
-- Test debug with non-existent index
SELECT bm25_dump_index('nonexistent_idx')::text ~ 'ERROR: Index ''nonexistent_idx'' not found' AS debug_nonexistent;
 debug_nonexistent 
-------------------
 t
(1 row)

-- Cleanup
DROP TABLE bar.baz CASCADE;
DROP SCHEMA bar CASCADE;
DROP TABLE docs.articles CASCADE;
DROP TABLE public_articles CASCADE;
DROP SCHEMA docs CASCADE;
DROP EXTENSION pg_textsearch CASCADE;
