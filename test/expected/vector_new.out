CREATE EXTENSION IF NOT EXISTS pg_textsearch;
CREATE EXTENSION

SET pg_textsearch.log_scores = true;
SET

SET client_min_messages = NOTICE;
SET

SET enable_seqscan = false;
SET

DROP TABLE IF EXISTS test_docs CASCADE;
DROP TABLE

CREATE TABLE test_docs (
    id SERIAL PRIMARY KEY,
    content TEXT
);
CREATE TABLE

INSERT INTO test_docs (content) VALUES
    ('the quick brown fox'),
    ('jumped over the lazy dog'),
    ('sphinx of black quartz'),
    ('hello world example'),
    ('postgresql full text search');
INSERT 0 5

CREATE INDEX docs_vector_idx ON test_docs USING bm25(content) WITH (text_config='english');
CREATE INDEX

SELECT 'docs_vector_idx:{hello:2,world:1}'::bm25vector;
            bm25vector             
-----------------------------------
 docs_vector_idx:{hello:2,world:1}
(1 row)


SELECT 'docs_vector_idx:{}'::bm25vector;
     bm25vector     
--------------------
 docs_vector_idx:{}
(1 row)


SELECT to_bm25vector('hello world', 'docs_vector_idx');
           to_bm25vector           
-----------------------------------
 docs_vector_idx:{hello:1,world:1}
(1 row)


SELECT to_bm25vector('postgresql search', 'docs_vector_idx');
              to_bm25vector              
-----------------------------------------
 docs_vector_idx:{postgresql:1,search:1}
(1 row)


SELECT to_bm25vector('', 'docs_vector_idx');  -- empty text
   to_bm25vector    
--------------------
 docs_vector_idx:{}
(1 row)

SELECT to_bm25vector('hello, world! How are you? I''m fine.', 'docs_vector_idx');  -- punctuation
                to_bm25vector                 
----------------------------------------------
 docs_vector_idx:{fine:1,hello:1,m:1,world:1}
(1 row)

SELECT to_bm25vector('Testing 123 with numbers and text', 'docs_vector_idx');  -- numbers
                 to_bm25vector                  
------------------------------------------------
 docs_vector_idx:{123:1,number:1,test:1,text:1}
(1 row)

SELECT to_bm25vector('hello', 'docs_vector_idx') = to_bm25vector('world', 'docs_vector_idx');
 ?column? 
----------
 f
(1 row)


\set VERBOSITY terse
\set ON_ERROR_STOP off
SELECT to_bm25vector('test text', 'nonexistent_index');

\set ON_ERROR_STOP on
\set VERBOSITY default
SELECT
    content,
    ROUND((content <@> to_bm25query('hello world', 'docs_vector_idx'))::numeric, 4) as score
FROM test_docs
ORDER BY score;
           content           |  score  
-----------------------------+---------
 hello world example         | -2.2549
 the quick brown fox         |  0.0000
 jumped over the lazy dog    |  0.0000
 sphinx of black quartz      |  0.0000
 postgresql full text search |  0.0000
(5 rows)

SELECT
    content,
    ROUND((content <@> to_bm25query('postgresql', 'docs_vector_idx'))::numeric, 4) as postgresql_score,
    ROUND((content <@> to_bm25query('search', 'docs_vector_idx'))::numeric, 4) as search_score
FROM test_docs
ORDER BY (content <@> to_bm25query('postgresql', 'docs_vector_idx'))::float8 +
         (content <@> to_bm25query('search', 'docs_vector_idx'))::float8;
           content           | postgresql_score | search_score 
-----------------------------+------------------+--------------
 postgresql full text search |          -0.9967 |      -0.9967
 the quick brown fox         |           0.0000 |       0.0000
 jumped over the lazy dog    |           0.0000 |       0.0000
 sphinx of black quartz      |           0.0000 |       0.0000
 hello world example         |           0.0000 |       0.0000
(5 rows)


SELECT to_bm25vector('hello', 'docs_vector_idx')::text;
       to_bm25vector       
---------------------------
 docs_vector_idx:{hello:1}
(1 row)


SELECT to_bm25vector('test word', 'docs_vector_idx')::text;
          to_bm25vector          
---------------------------------
 docs_vector_idx:{test:1,word:1}
(1 row)


SELECT to_bm25vector('this is a longer test with multiple words and repetitions test test', 'docs_vector_idx');
                        to_bm25vector                         
--------------------------------------------------------------
 docs_vector_idx:{longer:1,multipl:1,repetit:1,test:3,word:1}
(1 row)


SELECT
    to_bm25vector('hello world', 'docs_vector_idx') = to_bm25vector('hello world', 'docs_vector_idx') as should_be_true,
    to_bm25vector('hello world', 'docs_vector_idx') = to_bm25vector('world hello', 'docs_vector_idx') as depends_on_order;
 should_be_true | depends_on_order 
----------------+------------------
 t              | t
(1 row)


SELECT 'docs_vector_idx:{hello:1,world:2}'::bm25vector = 'docs_vector_idx:{hello:1,world:2}'::bm25vector;
 ?column? 
----------
 t
(1 row)


SELECT 'docs_vector_idx:{hello:1,world:2}'::bm25vector = 'docs_vector_idx:{world:2,hello:1}'::bm25vector;
 ?column? 
----------
 t
(1 row)


SELECT
    id,
    content,
    ROUND((content <@> to_bm25query('quick fox', 'docs_vector_idx'))::numeric, 4) as relevance
FROM test_docs
ORDER BY content <@> to_bm25query('quick fox', 'docs_vector_idx')  -- BM25 scoring for ranking
LIMIT 3;
 id |         content          | relevance 
----+--------------------------+-----------
  1 | the quick brown fox      |   -2.2549
  2 | jumped over the lazy dog |    0.0000
  3 | sphinx of black quartz   |    0.0000
(3 rows)

CREATE INDEX docs_simple_idx ON test_docs USING bm25(content) WITH (text_config='simple');
CREATE INDEX

SELECT
    'running' as query,
    to_bm25vector('running runner runs', 'docs_vector_idx') as english_stemmed,
    to_bm25vector('running runner runs', 'docs_simple_idx') as simple_no_stem;
  query  |         english_stemmed          |               simple_no_stem                
---------+----------------------------------+---------------------------------------------
 running | docs_vector_idx:{run:2,runner:1} | docs_simple_idx:{runner:1,running:1,runs:1}
(1 row)


\echo 'Testing ORDER BY vs standalone scoring consistency'
Testing ORDER BY vs standalone scoring consistency
WITH order_by_scores AS (
    SELECT id, content,
           ROUND((content <@> to_bm25query('fox dog', 'docs_simple_idx'))::numeric, 6) as order_by_score
    FROM test_docs
    ORDER BY content <@> to_bm25query('fox dog', 'docs_simple_idx')
    LIMIT 3
),
standalone_scores AS (
    SELECT id, content,
           ROUND((content <@> to_bm25query('fox dog', 'docs_simple_idx'))::numeric, 6) as standalone_score
    FROM test_docs
)
SELECT o.id,
       o.order_by_score,
       s.standalone_score,
       CASE WHEN abs(o.order_by_score - s.standalone_score) < 0.000001
            THEN '✓ SCORES MATCH'
            ELSE '✗ SCORES DIFFER'
       END as score_consistency
FROM order_by_scores o
JOIN standalone_scores s ON o.id = s.id
ORDER BY o.id;
 id | order_by_score | standalone_score | score_consistency 
----+----------------+------------------+-------------------
  1 |      -1.098612 |        -1.098612 | ✓ SCORES MATCH
  2 |      -0.996679 |        -0.996679 | ✓ SCORES MATCH
  3 |       0.000000 |         0.000000 | ✓ SCORES MATCH
(3 rows)


DROP INDEX docs_vector_idx;
DROP INDEX

DROP INDEX docs_simple_idx;
DROP INDEX

DROP TABLE test_docs;
DROP TABLE

DROP EXTENSION pg_textsearch CASCADE;
DROP EXTENSION
