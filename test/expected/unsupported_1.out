-- Test cases for queries that are NOT YET fully supported
-- These document known limitations of the current implicit index resolution
-- See DESIGN_INDEX_ERGONOMICS.md for details on PlaceHolderVar and future work
-- Load extension
CREATE EXTENSION IF NOT EXISTS pg_textsearch;
INFO:  pg_textsearch v0.0.6-dev: This is prerelease software and should not be used in production.
INFO:  This release contains breaking changes in the bm25 index structure and will require existing indexes to be rebuilt.
-- Setup test tables
CREATE TABLE docs (
    id SERIAL PRIMARY KEY,
    content TEXT
);
CREATE TABLE categories (
    id SERIAL PRIMARY KEY,
    doc_id INT REFERENCES docs(id),
    category TEXT
);
INSERT INTO docs (content) VALUES
    ('postgresql database management'),
    ('machine learning algorithms'),
    ('text search and retrieval');
INSERT INTO categories (doc_id, category) VALUES
    (1, 'technology'),
    (2, 'science'),
    (3, 'technology');
CREATE INDEX docs_bm25_idx ON docs USING bm25(content) WITH (text_config='english');
NOTICE:  BM25 index build started for relation docs_bm25_idx
NOTICE:  Using text search configuration: english
NOTICE:  Using index options: k1=1.20, b=0.75
NOTICE:  BM25 index build completed: 3 documents, avg_length=3.00, text_config='english' (k1=1.20, b=0.75)
SET enable_seqscan = off;
-- =============================================================================
-- LIMITATION 1: JOINs with score in SELECT
-- The CTID cache may not preserve scores correctly through JOIN operations
-- because the score is computed during the scan but projected after the JOIN.
-- =============================================================================
-- This query joins docs with categories and tries to return the score.
-- The score cache uses CTID, which may not map correctly after JOIN processing.
\echo 'Test: JOIN with score in SELECT list'
Test: JOIN with score in SELECT list
EXPLAIN (COSTS OFF)
SELECT d.id, d.content, c.category, d.content <@> 'database' as score
FROM docs d
JOIN categories c ON d.id = c.doc_id
ORDER BY d.content <@> 'database'
LIMIT 5;
                       QUERY PLAN                       
--------------------------------------------------------
 Limit
   ->  Nested Loop
         Join Filter: (d.id = c.doc_id)
         ->  Index Scan using docs_bm25_idx on docs d
               Order By: (content <@> 'database'::text)
         ->  Materialize
               ->  Seq Scan on categories c
(7 rows)

-- Execute to verify behavior (may show incorrect scores or zeros)
SELECT d.id, d.content, c.category,
       ROUND((d.content <@> 'database')::numeric, 4) as score
FROM docs d
JOIN categories c ON d.id = c.doc_id
ORDER BY d.content <@> 'database'
LIMIT 5;
 id |            content             |  category  |  score  
----+--------------------------------+------------+---------
  1 | postgresql database management | technology | -0.9808
(1 row)

-- =============================================================================
-- LIMITATION 2: Subqueries with score referenced in outer query
-- When the score is computed in a subquery but referenced outside,
-- the CTID cache cannot preserve it across the subquery boundary.
-- =============================================================================
\echo 'Test: Subquery with score referenced outside'
Test: Subquery with score referenced outside
EXPLAIN (COSTS OFF)
SELECT * FROM (
    SELECT id, content, content <@> 'machine' as score
    FROM docs
    ORDER BY content <@> 'machine'
    LIMIT 10
) sub
WHERE score < 0;
                      QUERY PLAN                       
-------------------------------------------------------
 Subquery Scan on sub
   Filter: (sub.score < '0'::double precision)
   ->  Limit
         ->  Index Scan using docs_bm25_idx on docs
               Order By: (content <@> 'machine'::text)
(5 rows)

-- Execute to see actual behavior
SELECT * FROM (
    SELECT id, content,
           ROUND((content <@> 'machine')::numeric, 4) as score
    FROM docs
    ORDER BY content <@> 'machine'
    LIMIT 10
) sub
WHERE score < 0;
 id |           content           |  score  
----+-----------------------------+---------
  2 | machine learning algorithms | -0.9808
(1 row)

-- =============================================================================
-- LIMITATION 3: CTEs (Common Table Expressions) with score
-- Similar to subqueries - score computed in CTE may not be preserved
-- when referenced in the main query.
-- =============================================================================
\echo 'Test: CTE with score'
Test: CTE with score
EXPLAIN (COSTS OFF)
WITH ranked_docs AS (
    SELECT id, content, content <@> 'search' as score
    FROM docs
    ORDER BY content <@> 'search'
    LIMIT 10
)
SELECT * FROM ranked_docs WHERE score < -0.5;
                        QUERY PLAN                        
----------------------------------------------------------
 Subquery Scan on ranked_docs
   Filter: (ranked_docs.score < '-0.5'::double precision)
   ->  Limit
         ->  Index Scan using docs_bm25_idx on docs
               Order By: (content <@> 'search'::text)
(5 rows)

-- Execute to see actual behavior
WITH ranked_docs AS (
    SELECT id, content,
           ROUND((content <@> 'search')::numeric, 4) as score
    FROM docs
    ORDER BY content <@> 'search'
    LIMIT 10
)
SELECT * FROM ranked_docs WHERE score < -0.5;
 id |          content          |  score  
----+---------------------------+---------
  3 | text search and retrieval | -0.9808
(1 row)

-- =============================================================================
-- LIMITATION 4: Multiple BM25 indexes on the same column
-- When there are multiple BM25 indexes on the same column (e.g., with
-- different text_config), the planner hook may pick the wrong one.
-- =============================================================================
\echo 'Test: Multiple BM25 indexes on same column'
Test: Multiple BM25 indexes on same column
-- Create a second index with different config
CREATE INDEX docs_bm25_simple_idx ON docs USING bm25(content)
    WITH (text_config='simple');
NOTICE:  BM25 index build started for relation docs_bm25_simple_idx
NOTICE:  Using text search configuration: simple
NOTICE:  Using index options: k1=1.20, b=0.75
NOTICE:  BM25 index build completed: 3 documents, avg_length=3.33, text_config='simple' (k1=1.20, b=0.75)
-- The planner hook finds the first matching index, which may not be
-- the one the user intended. Use explicit to_bm25query() for control.
EXPLAIN (COSTS OFF)
SELECT id, content <@> 'database' as score
FROM docs
ORDER BY content <@> 'database'
LIMIT 3;
WARNING:  multiple BM25 indexes exist on the same column
HINT:  Use explicit to_bm25query('query', 'index_name') to specify which index to use.
                     QUERY PLAN                      
-----------------------------------------------------
 Limit
   ->  Index Scan using docs_bm25_simple_idx on docs
         Order By: (content <@> 'database'::text)
(3 rows)

-- With explicit index, user has control:
EXPLAIN (COSTS OFF)
SELECT id, content <@> to_bm25query('database', 'docs_bm25_simple_idx') as score
FROM docs
ORDER BY content <@> to_bm25query('database', 'docs_bm25_simple_idx')
LIMIT 3;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Limit
   ->  Index Scan using docs_bm25_simple_idx on docs
         Order By: (content <@> 'docs_bm25_simple_idx:database'::bm25query)
(3 rows)

DROP INDEX docs_bm25_simple_idx;
-- =============================================================================
-- LIMITATION 5: Expression indexes
-- Expression indexes (e.g., lower(content)) are not supported.
-- The index build will fail with a clear error message.
-- =============================================================================
\echo 'Test: Expression index - should fail with error'
Test: Expression index - should fail with error
-- Expression indexes fail gracefully with an error
CREATE INDEX docs_lower_idx ON docs USING bm25(lower(content))
    WITH (text_config='simple');
NOTICE:  BM25 index build started for relation docs_lower_idx
ERROR:  BM25 indexes on expressions are not supported
HINT:  Create the index on a column directly, e.g., CREATE INDEX ... USING bm25(content)
-- =============================================================================
-- LIMITATION 6: Cross-table JOINs with BM25 on multiple tables
-- When both tables have BM25 indexes and both are used in the query,
-- each must resolve to its own index correctly.
-- =============================================================================
\echo 'Test: Cross-table JOINs with multiple BM25 indexes'
Test: Cross-table JOINs with multiple BM25 indexes
CREATE TABLE other_docs (
    id SERIAL PRIMARY KEY,
    body TEXT
);
INSERT INTO other_docs (body) VALUES
    ('database optimization techniques'),
    ('search engine algorithms');
CREATE INDEX other_docs_idx ON other_docs USING bm25(body)
    WITH (text_config='english');
NOTICE:  BM25 index build started for relation other_docs_idx
NOTICE:  Using text search configuration: english
NOTICE:  Using index options: k1=1.20, b=0.75
NOTICE:  BM25 index build completed: 2 documents, avg_length=3.00, text_config='english' (k1=1.20, b=0.75)
-- Query that scores both tables - each should resolve to correct index
EXPLAIN (COSTS OFF)
SELECT d.id, o.id,
       d.content <@> 'database' as doc_score,
       o.body <@> 'database' as other_score
FROM docs d, other_docs o
ORDER BY d.content <@> 'database'
LIMIT 5;
                       QUERY PLAN                       
--------------------------------------------------------
 Limit
   ->  Nested Loop
         ->  Index Scan using docs_bm25_idx on docs d
               Order By: (content <@> 'database'::text)
         ->  Materialize
               ->  Seq Scan on other_docs o
(6 rows)

-- Execute to verify both scores work
SELECT d.id as doc_id, o.id as other_id,
       ROUND((d.content <@> 'database')::numeric, 4) as doc_score,
       ROUND((o.body <@> 'database')::numeric, 4) as other_score
FROM docs d, other_docs o
ORDER BY d.content <@> 'database'
LIMIT 5;
 doc_id | other_id | doc_score | other_score 
--------+----------+-----------+-------------
      1 |        1 |   -0.9808 |     -0.9808
      1 |        2 |   -0.9808 |     -0.9808
(2 rows)

DROP TABLE other_docs CASCADE;
-- =============================================================================
-- LIMITATION 7: UNION queries
-- The text <@> text operator requires the score cache populated by index scan.
-- UNION queries use Merge Append which doesn't maintain cache context,
-- so this properly errors.
-- =============================================================================
\echo 'Test: UNION with scores'
Test: UNION with scores
CREATE TABLE docs2 (id serial, content text);
INSERT INTO docs2 (content) VALUES ('another database document');
CREATE INDEX docs2_idx ON docs2 USING bm25(content) WITH (text_config='english');
NOTICE:  BM25 index build started for relation docs2_idx
NOTICE:  Using text search configuration: english
NOTICE:  Using index options: k1=1.20, b=0.75
NOTICE:  BM25 index build completed: 1 documents, avg_length=3.00, text_config='english' (k1=1.20, b=0.75)
-- Scores from different indexes may not be directly comparable
EXPLAIN (COSTS OFF)
SELECT id, content, content <@> 'database' as score, 'docs' as source
FROM docs
UNION ALL
SELECT id, content, content <@> 'database' as score, 'docs2' as source
FROM docs2
ORDER BY score
LIMIT 5;
                       QUERY PLAN                        
---------------------------------------------------------
 Limit
   ->  Merge Append
         Sort Key: ((docs.content <@> 'database'::text))
         ->  Index Scan using docs_bm25_idx on docs
               Order By: (content <@> 'database'::text)
         ->  Index Scan using docs2_idx on docs2
               Order By: (content <@> 'database'::text)
(7 rows)

-- Execute to see actual behavior
-- The text <@> text operator requires the score cache populated by index scan.
-- UNION queries use Merge Append which doesn't maintain cache context,
-- so this properly errors.
SELECT id, content,
       ROUND((content <@> 'database')::numeric, 4) as score,
       'docs' as source
FROM docs
UNION ALL
SELECT id, content,
       ROUND((content <@> 'database')::numeric, 4) as score,
       'docs2' as source
FROM docs2
ORDER BY score
LIMIT 5;
ERROR:  text <@> text operator requires ORDER BY clause
HINT:  Use ORDER BY content <@> 'query' to enable BM25 scoring, or use to_bm25query('query', 'index_name') to specify an index explicitly.
DROP TABLE docs2 CASCADE;
-- =============================================================================
-- LIMITATION 8: Aggregate functions on scores
-- The text <@> text operator requires the score cache populated by index scan.
-- Aggregate queries typically use Seq Scan which doesn't maintain cache context,
-- so this properly errors.
-- =============================================================================
\echo 'Test: Aggregate on scores'
Test: Aggregate on scores
-- This errors because the score cache is not populated without an index scan
SELECT COUNT(*) as matching_docs,
       ROUND(AVG((content <@> 'database')::numeric), 4) as avg_score,
       ROUND(MIN((content <@> 'database')::numeric), 4) as best_score
FROM docs
WHERE content <@> 'database' < 0;
ERROR:  text <@> text operator requires ORDER BY clause
HINT:  Use ORDER BY content <@> 'query' to enable BM25 scoring, or use to_bm25query('query', 'index_name') to specify an index explicitly.
-- =============================================================================
-- LIMITATION 9: Window functions with scores
-- Window functions may evaluate score multiple times or at wrong time
-- =============================================================================
\echo 'Test: Window functions with scores'
Test: Window functions with scores
EXPLAIN (COSTS OFF)
SELECT id, content,
       content <@> 'database' as score,
       ROW_NUMBER() OVER (ORDER BY content <@> 'database') as rank
FROM docs
ORDER BY content <@> 'database'
LIMIT 5;
                       QUERY PLAN                       
--------------------------------------------------------
 Limit
   ->  WindowAgg
         ->  Index Scan using docs_bm25_idx on docs
               Order By: (content <@> 'database'::text)
(4 rows)

-- Execute to verify behavior
SELECT id, content,
       ROUND((content <@> 'database')::numeric, 4) as score,
       ROW_NUMBER() OVER (ORDER BY content <@> 'database') as rank
FROM docs
ORDER BY content <@> 'database'
LIMIT 5;
 id |            content             |  score  | rank 
----+--------------------------------+---------+------
  1 | postgresql database management | -0.9808 |    1
(1 row)

-- =============================================================================
-- WORKAROUND EXAMPLES
-- These show how to handle unsupported cases using explicit syntax
-- =============================================================================
\echo 'Workaround: Use explicit to_bm25query for complex queries'
Workaround: Use explicit to_bm25query for complex queries
-- For JOINs, compute score explicitly with index name
SELECT d.id, d.content, c.category,
       ROUND((d.content <@> to_bm25query('database', 'docs_bm25_idx'))::numeric, 4) as score
FROM docs d
JOIN categories c ON d.id = c.doc_id
ORDER BY d.content <@> to_bm25query('database', 'docs_bm25_idx')
LIMIT 5;
 id |            content             |  category  |  score  
----+--------------------------------+------------+---------
  1 | postgresql database management | technology | -0.9808
(1 row)

-- Cleanup
DROP TABLE categories CASCADE;
DROP TABLE docs CASCADE;
DROP EXTENSION pg_textsearch CASCADE;
