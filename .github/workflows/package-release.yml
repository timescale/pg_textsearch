name: Package Release

on:
  workflow_dispatch:
    inputs:
      tag:
        description: 'Tag/Version (e.g. v0.0.2)'
        required: true
        type: string
  push:
    tags:
      - 'v*'

permissions:
  contents: write  # Needed to upload assets to releases

jobs:
  test-upgrades:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        # Only test PG17 for upgrades from old versions
        # since PG18 support was added in v0.0.3
        pg_version: [17]
        old_version: ['0.0.1', '0.0.2']

    steps:
    - uses: actions/checkout@v4
      with:
        ref: ${{ github.event.inputs.tag || github.ref }}

    - name: Install PostgreSQL ${{ matrix.pg_version }}
      run: |
        sudo apt-get update
        sudo apt-get install -y wget ca-certificates
        wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add -
        echo "deb http://apt.postgresql.org/pub/repos/apt/ $(lsb_release -cs)-pgdg main" | sudo tee /etc/apt/sources.list.d/pgdg.list
        sudo apt-get update
        sudo apt-get install -y postgresql-${{ matrix.pg_version }} postgresql-server-dev-${{ matrix.pg_version }}
        sudo systemctl stop postgresql

    - name: Build current version
      run: |
        export PG_CONFIG=/usr/lib/postgresql/${{ matrix.pg_version }}/bin/pg_config
        make clean
        make
        sudo make install

    - name: Download and install old version
      run: |
        # Download old release
        wget -q https://github.com/Tapir-Database/pg_textsearch/releases/download/v${{ matrix.old_version }}/pg_textsearch-${{ matrix.old_version }}.tar.gz || {
          echo "Warning: Could not download v${{ matrix.old_version }} - skipping this upgrade test"
          echo "SKIP_TEST=true" >> $GITHUB_ENV
          exit 0
        }

        # Extract and build old version
        tar -xzf pg_textsearch-${{ matrix.old_version }}.tar.gz
        cd pg_textsearch-${{ matrix.old_version }}

        export PG_CONFIG=/usr/lib/postgresql/${{ matrix.pg_version }}/bin/pg_config
        make clean
        make

        # Save old .so file
        cp pg_textsearch.so ../pg_textsearch_old.so
        cd ..

    - name: Test upgrade path
      if: env.SKIP_TEST != 'true'
      run: |
        # Setup test database
        export PATH=/usr/lib/postgresql/${{ matrix.pg_version }}/bin:$PATH
        export PGDATA=/tmp/test_pgdata

        initdb -D $PGDATA
        echo "shared_buffers = 256MB" >> $PGDATA/postgresql.conf
        echo "port = 5432" >> $PGDATA/postgresql.conf
        echo "unix_socket_directories = '/tmp'" >> $PGDATA/postgresql.conf

        pg_ctl -D $PGDATA start -w
        createdb -h /tmp test_upgrade

        # Install old version
        sudo cp pg_textsearch_old.so /usr/lib/postgresql/${{ matrix.pg_version }}/lib/pg_textsearch.so

        psql -h /tmp -d test_upgrade -c "CREATE EXTENSION pg_textsearch VERSION '${{ matrix.old_version }}';"

        # Create test data with old version
        psql -h /tmp -d test_upgrade << SQL
        CREATE TABLE test_docs (
          id SERIAL PRIMARY KEY,
          content TEXT
        );

        INSERT INTO test_docs (content) VALUES
          ('PostgreSQL is a powerful database system'),
          ('Full text search with BM25 ranking'),
          ('Testing upgrade from version ${{ matrix.old_version }}');

        CREATE INDEX idx_test_bm25 ON test_docs
        USING bm25 (content) WITH (text_config = 'english');

        -- Verify search works
        SELECT COUNT(*) FROM test_docs
        WHERE content @@ to_tsquery('english', 'postgresql');
        SQL

        # Install new version
        sudo make install

        # Perform upgrade
        psql -h /tmp -d test_upgrade -c "ALTER EXTENSION pg_textsearch UPDATE;"

        # Verify upgrade
        psql -h /tmp -d test_upgrade << SQL
        -- Check version
        SELECT extversion FROM pg_extension WHERE extname = 'pg_textsearch';

        -- Test that old index still works
        SELECT COUNT(*) FROM test_docs
        WHERE content @@ to_tsquery('english', 'postgresql');

        -- Test creating new index after upgrade
        CREATE TABLE new_docs (
          id SERIAL PRIMARY KEY,
          content TEXT
        );

        INSERT INTO new_docs (content) VALUES ('New document after upgrade');

        CREATE INDEX idx_new_bm25 ON new_docs
        USING bm25 (content) WITH (text_config = 'english');

        SELECT COUNT(*) FROM new_docs
        WHERE content @@ to_tsquery('english', 'upgrade');
        SQL

        # Cleanup
        pg_ctl -D $PGDATA stop -m immediate
        rm -rf $PGDATA

    - name: Report upgrade test result
      if: always()
      run: |
        if [ "$SKIP_TEST" = "true" ]; then
          echo "⚠️ Upgrade test from v${{ matrix.old_version }} was skipped (old version not available)"
        else
          echo "✅ Upgrade test from v${{ matrix.old_version }} to current version on PostgreSQL ${{ matrix.pg_version }} completed successfully"
        fi

  build-packages:
    needs: test-upgrades
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        pg_version: [17, 18]
        platform:
          - type: amd64
            docker_platform: linux/amd64
          - type: arm64
            docker_platform: linux/arm64

    steps:
    - uses: actions/checkout@v4
      with:
        ref: ${{ github.event.inputs.tag || github.ref }}

    - name: Set version
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "VERSION=${{ github.event.inputs.tag }}" >> $GITHUB_ENV
        else
          echo "VERSION=${GITHUB_REF#refs/tags/}" >> $GITHUB_ENV
        fi
        echo "Building version: $VERSION"

    - name: Set up QEMU
      uses: docker/setup-qemu-action@v3
      with:
        platforms: arm64

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Build extension in Docker
      run: |
        # Create a build script
        cat > build.sh << 'BUILDSCRIPT'
        #!/bin/bash
        set -ex

        # The TimescaleDB builder image should have build tools installed
        # Build the extension
        cd /build
        export PG_CONFIG=/usr/local/bin/pg_config
        make clean
        CFLAGS="-O3 -DNDEBUG" make

        # Package the extension
        bash scripts/package-deb.sh "$1" "$PWD" "$2" "$3"
        BUILDSCRIPT

        chmod +x build.sh

        # Run build in TimescaleDB container with proper architecture
        # Run as root to install dependencies
        docker run --rm \
          --platform ${{ matrix.platform.docker_platform }} \
          -v "$PWD:/build" \
          -w /build \
          --user root \
          timescale/timescaledb-ha:pg${{ matrix.pg_version }}-all \
          bash -c "apt-get update && apt-get install -y build-essential postgresql-server-dev-${{ matrix.pg_version }} && /build/build.sh '$VERSION' '${{ matrix.platform.type }}' '${{ matrix.pg_version }}'"

    - name: Verify package architecture
      run: |
        # Fix permissions after Docker build (Docker runs as root)
        sudo chown -R $USER:$USER dist/

        # Extract and check the actual binary architecture
        mkdir -p check-arch
        dpkg-deb -x dist/*.deb check-arch/
        file check-arch/usr/lib/postgresql/*/lib/pg_textsearch.so | grep -E "(x86-64|aarch64)" || true
        rm -rf check-arch

    - name: Create zip archive
      run: |
        cd dist
        # Create zip with the expected naming convention for timescaledb-docker-cloud
        zip pg-textsearch-${{ env.VERSION }}-pg${{ matrix.pg_version }}-${{ matrix.platform.type }}.zip *.deb
        cd ..

    - name: Upload package artifacts
      uses: actions/upload-artifact@v4
      with:
        name: pg-textsearch-${{ env.VERSION }}-pg${{ matrix.pg_version }}-${{ matrix.platform.type }}
        path: |
          dist/*.deb
          dist/*.zip
        retention-days: 30

  build-source:
    needs: test-upgrades
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
      with:
        ref: ${{ github.event.inputs.tag || github.ref }}

    - name: Set version
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "VERSION=${{ github.event.inputs.tag }}" >> $GITHUB_ENV
        else
          echo "VERSION=${GITHUB_REF#refs/tags/}" >> $GITHUB_ENV
        fi
        echo "Building version: $VERSION"

    - name: Create source tarball
      run: |
        # Clean version without 'v' prefix
        CLEAN_VERSION=${VERSION#v}

        # Create directory with version
        mkdir -p pg_textsearch-${CLEAN_VERSION}

        # Copy source files
        cp -r src sql test benchmarks Makefile pg_textsearch.control README.md LICENSE pg_textsearch-${CLEAN_VERSION}/

        # Create tarball
        tar -czf pg_textsearch-${CLEAN_VERSION}.tar.gz pg_textsearch-${CLEAN_VERSION}/

        # Also create a .tar.bz2
        tar -cjf pg_textsearch-${CLEAN_VERSION}.tar.bz2 pg_textsearch-${CLEAN_VERSION}/

        mkdir -p dist
        mv pg_textsearch-${CLEAN_VERSION}.tar.* dist/

    - name: Upload source artifacts
      uses: actions/upload-artifact@v4
      with:
        name: pg-textsearch-source-${{ env.VERSION }}
        path: dist/pg_textsearch-*.tar.*
        retention-days: 30

  release:
    needs: [build-packages, build-source]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/')

    steps:
    - uses: actions/checkout@v4

    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        path: artifacts

    - name: Upload Release Assets
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        TAG_NAME="${GITHUB_REF#refs/tags/}"

        # Check if release exists, create if it doesn't
        if ! gh release view "$TAG_NAME" &>/dev/null; then
          echo "Creating release for tag $TAG_NAME"
          gh release create "$TAG_NAME" \
            --title "Release $TAG_NAME" \
            --notes "Release $TAG_NAME" \
            --draft
        fi

        # Upload .zip and source packages
        for file in artifacts/*/*.zip artifacts/*/*.tar.*; do
          if [ -f "$file" ]; then
            echo "Uploading $(basename "$file") to release $TAG_NAME"
            gh release upload "$TAG_NAME" "$file" --clobber
          fi
        done
